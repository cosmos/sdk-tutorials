(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{747:function(e,t,a){"use strict";a.r(t);var n=a(1),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"transport-authentication-and-ordering-layer-channels"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transport-authentication-and-ordering-layer-channels"}},[e._v("#")]),e._v(" Transport, Authentication, and Ordering Layer - Channels")]),e._v(" "),a("HighlightBox",{attrs:{type:"learning"}},[a("p",[e._v("In this section, you will:")]),e._v(" "),a("ul",[a("li",[e._v("Establish a channel.")]),e._v(" "),a("li",[e._v("Learn about the application packet flow.")])])]),e._v(" "),a("p",[e._v("Connections and clients comprise the main components of the transport layer in IBC. However, application to application communication in IBC is conducted over "),a("strong",[e._v("channels")]),e._v(", which route between an application module such as the module which handles Interchain Standard (ICS) 20 token transfers on one chain, and the corresponding application module on another one. These applications are namespaced by "),a("strong",[e._v("port identifiers")]),e._v(" such as 'transfer' for ICS-20 token transfers.")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v("Note that, in the case of interchain accounts, there are two different port IDs for host and controller modules:\n"),a("br"),a("br"),e._v(" "),a("code",[e._v("icahost")]),e._v(" is the default port id that the interchain accounts host submodule binds to, whereas "),a("code",[e._v("icacontroller-")]),e._v(" is the default port prefix that the interchain accounts controller submodule binds to.")])]),e._v(" "),a("p",[e._v("Contrary to the core IBC transport layer logic, which handles only verification, ordering, and all around basic packet correctness, the application layer over channels handles only the application-specific logic which interprets the packets that have been sent over the transport layer. This split between transport and application layer in IBC is similar to the split between Tendermint's consensus layer (consensus, mempool, ordering of transactions) and ABCI layer (process of those transaction bytes).")]),e._v(" "),a("p",[e._v("A connection may have any number of associated channels. However, each channel is associated with only one connection ID, which indicates which light client it is secured by, and one port ID which indicates the application that it is connected to.")]),e._v(" "),a("p",[e._v("As mentioned above, channels are payload agnostic. The application modules sending and receiving IBC packets decide how to interpret and act upon the incoming packet data, and use their own application logic and handlers to determine which state transitions to apply according to the data contained in each received packet.")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("ul",[a("li",[e._v("An "),a("strong",[e._v("ordered channel")]),e._v(" is "),a("em",[e._v("a channel where packets are delivered exactly in the order in which they were sent")]),e._v(".")]),e._v(" "),a("li",[e._v("An "),a("strong",[e._v("unordered channel")]),e._v(" is "),a("em",[e._v("a channel where packets can be delivered in any order")]),e._v(", which may differ from the order in which they were sent.")])])]),e._v(" "),a("h2",{attrs:{id:"establishing-a-channel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#establishing-a-channel"}},[e._v("#")]),e._v(" Establishing a Channel")]),e._v(" "),a("p",[e._v("Similarly to how connections are established, channels are established through a four way handshake, in which each step is initiated by a relayer:")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/4-ibc/images/channelhandshake.png"}})],1),e._v(" "),a("ol",[a("li",[a("code",[e._v("ChanOpenInit")]),e._v(": will set the chain A into "),a("code",[e._v("INIT")]),e._v(" state. This will call "),a("code",[e._v("OnChanOpenInit")]),e._v(" so application A can apply the custom callback that it has set on "),a("code",[e._v("INIT")]),e._v(", e.g. check if the port has been set correctly, the channel is indeed unordered/ordered as expected, etc. An application version is also proposed in this step.")]),e._v(" "),a("li",[a("code",[e._v("ChanOpenTry")]),e._v(": will set chain B into "),a("code",[e._v("TRY")]),e._v(" state. It will call "),a("code",[e._v("OnChanOpenConfirm")]),e._v(" so application B can apply its custom "),a("code",[e._v("TRY")]),e._v(" callback. Application version negotiation also happens during this step.")]),e._v(" "),a("li",[a("code",[e._v("ChanOpenAck")]),e._v(": will set the chain A into "),a("code",[e._v("OPEN")]),e._v(" state. This will call "),a("code",[e._v("OnChanOpenAck")]),e._v(" which will be implemented by the application. Application version negotiation is finalised during this step.")]),e._v(" "),a("li",[a("code",[e._v("ChanOpenConfirm")]),e._v(": will set chain B into "),a("code",[e._v("OPEN")]),e._v(" state so application B can apply its "),a("code",[e._v("CONFIRM")]),e._v(" logic.")])]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v('"Crossing Hellos" refers to a situation when both chains attempt the same handshake step at the same time.\n'),a("br"),a("br"),e._v("\nIf both chains submit "),a("code",[e._v("OpenInit")]),e._v(" then "),a("code",[e._v("OpenTry")]),e._v(" at same time, there should be no error. In this case, both sides will need to confirm with an "),a("code",[e._v("OpenAck")]),e._v(", and then no "),a("code",[e._v("OpenConfirm")]),e._v(" is required because both ConnectionEnds will be in state OPEN after the successful "),a("code",[e._v("OpenAck")]),e._v(".")])]),e._v(" "),a("h2",{attrs:{id:"example-code-channelopeninit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example-code-channelopeninit"}},[e._v("#")]),e._v(" Example code: ChannelOpenInit")]),e._v(" "),a("p",[e._v("You can find the implementation of "),a("code",[e._v("ChannelOpenInit")]),e._v(" in the the "),a("a",{attrs:{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/keeper/msg_server.go",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("msg_server.go")]),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("The important part to note in this code snippet is that an application module has capabilities for the requested port. Therefore, an application module can only use a channel and port if the application owns the capability for that port and the module which attempting to open a channel is the module we have granted capabilities to in "),a("code",[e._v("app.go")]),e._v(":")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"Ly8gQ2hhbm5lbE9wZW5Jbml0IGRlZmluZXMgYSBycGMgaGFuZGxlciBtZXRob2QgZm9yIE1zZ0NoYW5uZWxPcGVuSW5pdC4KLy8gQ2hhbm5lbE9wZW5Jbml0IHdpbGwgcGVyZm9ybSAwNC1jaGFubmVsIGNoZWNrcywgcm91dGUgdG8gdGhlIGFwcGxpY2F0aW9uCi8vIGNhbGxiYWNrLCBhbmQgd3JpdGUgYW4gT3BlbkluaXQgY2hhbm5lbCBpbnRvIHN0YXRlIHVwb24gc3VjY2Vzc2Z1bCBleGVjdXRpb24uCmZ1bmMgKGsgS2VlcGVyKSBDaGFubmVsT3BlbkluaXQoZ29DdHggY29udGV4dC5Db250ZXh0LCBtc2cgKmNoYW5uZWx0eXBlcy5Nc2dDaGFubmVsT3BlbkluaXQpICgqY2hhbm5lbHR5cGVzLk1zZ0NoYW5uZWxPcGVuSW5pdFJlc3BvbnNlLCBlcnJvcikgewogICAgY3R4IDo9IHNkay5VbndyYXBTREtDb250ZXh0KGdvQ3R4KQoKICAgIC8vIExvb2t1cCBtb2R1bGUgYnkgcG9ydCBjYXBhYmlsaXR5CiAgICBtb2R1bGUsIHBvcnRDYXAsIGVyciA6PSBrLlBvcnRLZWVwZXIuTG9va3VwTW9kdWxlQnlQb3J0KGN0eCwgbXNnLlBvcnRJZCkKICAgIGlmIGVyciAhPSBuaWwgewogICAgICAgIHJldHVybiBuaWwsIHNka2Vycm9ycy5XcmFwKGVyciwgJnF1b3Q7Y291bGQgbm90IHJldHJpZXZlIG1vZHVsZSBmcm9tIHBvcnQtaWQmcXVvdDspCiAgICB9CgogICAgLi4uCgogICAgLy8gUGVyZm9ybSAwNC1jaGFubmVsIHZlcmlmaWNhdGlvbgogICAgY2hhbm5lbElELCBjYXAsIGVyciA6PSBrLkNoYW5uZWxLZWVwZXIuQ2hhbk9wZW5Jbml0KAogICAgICAgIGN0eCwgbXNnLkNoYW5uZWwuT3JkZXJpbmcsIG1zZy5DaGFubmVsLkNvbm5lY3Rpb25Ib3BzLCBtc2cuUG9ydElkLAogICAgICAgIHBvcnRDYXAsIG1zZy5DaGFubmVsLkNvdW50ZXJwYXJ0eSwgbXNnLkNoYW5uZWwuVmVyc2lvbiwKICAgICkKCiAgICAuLi4KCiAgICAvLyBQZXJmb3JtIGFwcGxpY2F0aW9uIGxvZ2ljIGNhbGxiYWNrCiAgICBpZiBlcnIgPSBjYnMuT25DaGFuT3BlbkluaXQoY3R4LCBtc2cuQ2hhbm5lbC5PcmRlcmluZywgbXNnLkNoYW5uZWwuQ29ubmVjdGlvbkhvcHMsIG1zZy5Qb3J0SWQsIGNoYW5uZWxJRCwgY2FwLCBtc2cuQ2hhbm5lbC5Db3VudGVycGFydHksIG1zZy5DaGFubmVsLlZlcnNpb24pOyBlcnIgIT0gbmlsIHsKICAgICAgICByZXR1cm4gbmlsLCBzZGtlcnJvcnMuV3JhcChlcnIsICZxdW90O2NoYW5uZWwgb3BlbiBpbml0IGNhbGxiYWNrIGZhaWxlZCZxdW90OykKICAgIH0KCiAgICAvLyBXcml0ZSBjaGFubmVsIGludG8gc3RhdGUKICAgIGsuQ2hhbm5lbEtlZXBlci5Xcml0ZU9wZW5Jbml0Q2hhbm5lbChjdHgsIG1zZy5Qb3J0SWQsIGNoYW5uZWxJRCwgbXNnLkNoYW5uZWwuT3JkZXJpbmcsIG1zZy5DaGFubmVsLkNvbm5lY3Rpb25Ib3BzLCBtc2cuQ2hhbm5lbC5Db3VudGVycGFydHksIG1zZy5DaGFubmVsLlZlcnNpb24pCgogICAgcmV0dXJuICZhbXA7Y2hhbm5lbHR5cGVzLk1zZ0NoYW5uZWxPcGVuSW5pdFJlc3BvbnNlewogICAgICAgIENoYW5uZWxJZDogY2hhbm5lbElELAogICAgfSwgbmlsCn0K"}}),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[a("strong",[e._v("Capabilities")])]),e._v(" "),a("p",[e._v("IBC is intended to work in execution environments where modules do not necessarily trust each other. This security is accomplished using a "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-003-dynamic-capability-store.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("dynamic capability store"),a("OutboundLink")],1),e._v(". This binding strategy prevents other modules from using the particular port or channel since those modules do not own the appropriate capability.\n"),a("br"),a("br"),e._v("\nWhile this background information is useful, IBC application developers should not need to modify this lower level abstraction, other than setting the capabilities appropriately in "),a("code",[e._v("app.go")]),e._v(".")])]),e._v(" "),a("h2",{attrs:{id:"application-packet-flow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#application-packet-flow"}},[e._v("#")]),e._v(" Application packet flow")]),e._v(" "),a("p",[e._v("As stated previously, application modules communicate with each other by sending packets over IBC channels. However, IBC modules do not directly pass these messages to each other over the network. Rather, the module will commit some state reflecting the transaction execution to a precisely defined path reserved for a specific message type and a specific counterparty. For example, as part of an ICS-20 token transfer, the bank module would escrow the portion of tokens to be transferred and store the proof of this escrow.")]),e._v(" "),a("p",[e._v("A relayer will monitor channels for events emitted when updates have been submitted to these paths, and (after first submitting an "),a("code",[e._v("UpdateClient")]),e._v(" to update the sending chain light client on the destination chain) relay the message containing the packet data along with a proof that the state transition contained in the message has been commited to the state of the sending chain. The destination chain then verifies this packet and packet commitmentment proof against the state contained in the light client.")]),e._v(" "),a("p",[e._v("Take a look at the "),a("a",{attrs:{href:"https://github.com/cosmos/ibc-go/blob/main/modules/core/04-channel/types/packet.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("packet definition"),a("OutboundLink")],1),e._v(" to see the packet structure:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"Ly8gTmV3UGFja2V0IGNyZWF0ZXMgYSBuZXcgUGFja2V0IGluc3RhbmNlLiBJdCBwYW5pY3MgaWYgdGhlIHByb3ZpZGVkCi8vIHBhY2tldCBkYXRhIGludGVyZmFjZSBpcyBub3QgcmVnaXN0ZXJlZC4KZnVuYyBOZXdQYWNrZXQoCiAgICBkYXRhIFtdYnl0ZSwKICAgIHNlcXVlbmNlIHVpbnQ2NCwgc291cmNlUG9ydCwgc291cmNlQ2hhbm5lbCwKICAgIGRlc3RpbmF0aW9uUG9ydCwgZGVzdGluYXRpb25DaGFubmVsIHN0cmluZywKICAgIHRpbWVvdXRIZWlnaHQgY2xpZW50dHlwZXMuSGVpZ2h0LCB0aW1lb3V0VGltZXN0YW1wIHVpbnQ2NCwKKSBQYWNrZXQgewogICAgcmV0dXJuIFBhY2tldHsKICAgICAgICBEYXRhOiAgICAgICAgICAgICAgIGRhdGEsCiAgICAgICAgU2VxdWVuY2U6ICAgICAgICAgICBzZXF1ZW5jZSwKICAgICAgICBTb3VyY2VQb3J0OiAgICAgICAgIHNvdXJjZVBvcnQsCiAgICAgICAgU291cmNlQ2hhbm5lbDogICAgICBzb3VyY2VDaGFubmVsLAogICAgICAgIERlc3RpbmF0aW9uUG9ydDogICAgZGVzdGluYXRpb25Qb3J0LAogICAgICAgIERlc3RpbmF0aW9uQ2hhbm5lbDogZGVzdGluYXRpb25DaGFubmVsLAogICAgICAgIFRpbWVvdXRIZWlnaHQ6ICAgICAgdGltZW91dEhlaWdodCwKICAgICAgICBUaW1lb3V0VGltZXN0YW1wOiAgIHRpbWVvdXRUaW1lc3RhbXAsCiAgICB9Cn0K"}}),e._v(" "),a("p",[a("code",[e._v("Sequence")]),e._v(" denotes the sequence number of the packet in the channel.")]),e._v(" "),a("p",[a("code",[e._v("TimeoutTimestamp")]),e._v(" and "),a("code",[e._v("TimeoutHeight")]),e._v(" dictate the time before which the receiving module must process a packet.")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/4-ibc/images/packetflow.png"}})],1),e._v(" "),a("h2",{attrs:{id:"success-case"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#success-case"}},[e._v("#")]),e._v(" Success case")]),e._v(" "),a("p",[e._v("In the first step of a successful packet flow, application A will send a packet (call "),a("code",[e._v("sendPacket")]),e._v(") to application B. "),a("code",[e._v("SendPacket")]),e._v(" can be triggered by a user, but applications can also trigger this as the result of some other application logic.")]),e._v(" "),a("p",[e._v("Core IBC A will commit the packet to its own state and the relayer can query this packet and send a "),a("code",[e._v("RecvPacket")]),e._v(" message to core IBC B. Core IBC handles a number of verifications, including verifying that the packet was indeed sent by chain A, that the packet came in the correct order if it was sent over an ordered channel, that the state commitment proof is valid, etc. If this verification step is successful, core IBC will then route the packet to application B.")]),e._v(" "),a("p",[e._v("Note that core IBC is unopinionated about the actual content of the packet data, as this data is at this point just bytes. It is the responsibility of the applications on either end to marshal and unmarshal the data from and to the expected data structures on either side. This is also why application version negotiation as discussed previously in the channel handshakes is important, as different versions of an application may result in different expected data structures on either end of the channel and application.")]),e._v(" "),a("p",[e._v("After receiving the packet data from core IBC, application B will then marshal the data blob into the expected structure and apply the relevant application logic. In the case of an ICS-20 token transfer, for example, this would entail the minting of the received tokens on chain B to the specified receiver user account. Application B will then send an "),a("code",[e._v("Acknowledgment")]),e._v(" message to core IBC B, which will again commit it to its own state so it can be queried and sent by a relayer to core IBC A.")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[a("strong",[e._v("Synchronous and asynchronous acknowledgements")])]),e._v(" "),a("p",[e._v("Acknowledgements can either take place synchronously or asynchronously. What this means is that the "),a("code",[e._v("OnRecvPacket")]),e._v(" callback has a return value "),a("code",[e._v("Acknowledgement")]),e._v(" which is optional.\n"),a("br"),a("br"),e._v("\nIn the case of a synchronous "),a("code",[e._v("Acknowledgement")]),e._v(", the callback will return an "),a("code",[e._v("Acknowledgement")]),e._v(" at the end of the process and a relayer can query this "),a("code",[e._v("Acknowledgement")]),e._v(" packet and relay immediately after the process has finished. This is useful in cases in which application A is expecting an "),a("code",[e._v("AckPacket")]),e._v(" in order to initiate some application logic "),a("code",[e._v("OnAcknowledgePacket")]),e._v(". For example, the sending chain of an ICS-20 token transfer will do nothing in the case of a successful "),a("code",[e._v("AckPacket")]),e._v(", but in the case where an error is returned, the sending chain will unescrow the previously locked tokens.\n"),a("br"),a("br"),e._v("\nIn the case of applications like Interchain Security, there is an asynchronous "),a("code",[e._v("Acknowledgement")]),e._v(" flow. This means that the "),a("code",[e._v("Acknowledgement")]),e._v(" is not sent as part of the return value of "),a("code",[e._v("OnRecvPacket")]),e._v(", but it is sent at some later point. IBC is designed to handle this case by allowing for "),a("code",[e._v("Acknowledgements")]),e._v(" to be committed or queried asynchronously.\n"),a("br"),a("br"),e._v("\nIn either case, even if there is no application specific logic to be initiated as a direct result of a received "),a("code",[e._v("Acknowledgement")]),e._v(", "),a("code",[e._v("OnAcknowledgePacket")]),e._v(" will at the very least remove the commitment proof from the store to avoid cluttering the store with old data.")])]),e._v(" "),a("h2",{attrs:{id:"timeout-case"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#timeout-case"}},[e._v("#")]),e._v(" Timeout case")]),e._v(" "),a("p",[e._v("In the case that a packet is time-sensitive and the timeout block height or timeout timestamp specified in the packet parameters "),a("strong",[e._v("based on chain B's time")]),e._v(" has elapsed, whatever state transitions have occured as a result of the sent packet should be reversed.")]),e._v(" "),a("p",[e._v("In these cases, the initial flow is the same, with core IBC A first committing the packet to its own state. However, instead of querying for the packet, a relayer will submit a  "),a("code",[e._v("QueryNonReceipt")]),e._v(" to receive a proof that the packet was not received by core IBC B. It can then send the "),a("code",[e._v("TimeoutPacket")]),e._v(" to core IBC A, which will then trigger the relevant "),a("code",[e._v("OnTimeoutPacket")]),e._v(" application logic. For example, the ICS-20 token transfer application will unescrow the locked up tokens and send these back to the original sender "),a("code",[e._v("OnTimeoutPacket")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"next-up"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#next-up"}},[e._v("#")]),e._v(" Next up")]),e._v(" "),a("p",[e._v("You learned how to establish a channel and discovered the application packet flow. In the "),a("RouterLink",{attrs:{to:"/academy/4-ibc/clients.html"}},[e._v("next section")]),e._v(", you get to explore clients in IBC/TAO.")],1)],1)}),[],!1,null,null,null);t.default=o.exports}}]);