(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{713:function(e,t,a){"use strict";a.r(t);var s=a(1),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"baseapp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#baseapp"}},[e._v("#")]),e._v(" BaseApp")]),e._v(" "),a("HighlightBox",{attrs:{type:"prerequisite"}},[a("p",[e._v("Before looking at "),a("code",[e._v("BaseApp")]),e._v(", make sure to read the previous sections:")]),e._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/academy/2-main-concepts/architecture.html"}},[e._v("A Blockchain App Architecture")])],1),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/academy/2-main-concepts/transactions.html"}},[e._v("Transactions")])],1),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/academy/2-main-concepts/messages.html"}},[e._v("Messages")])],1),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/academy/2-main-concepts/modules.html"}},[e._v("Modules")])],1),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/academy/2-main-concepts/multistore-keepers.html"}},[e._v("Multistore and Keepers")])],1)])]),e._v(" "),a("HighlightBox",{attrs:{type:"learning"}},[a("p",[e._v("In this section you will discover how to define an application state machine and service router, how to create custom transaction processing, and how to create periodic processes that execute at the beginning or end of each block.")])]),e._v(" "),a("p",[a("code",[e._v("BaseApp")]),e._v(" is a boilerplate implementation of a Cosmos SDK application. This abstraction implements functionalities that every Cosmos application needs, starting with an implementation of the Tendermint Application Blockchain Interface (ABCI).")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v("The Tendermint consensus is application agnostic. It establishes the canonical transaction list and sends confirmed transactions to Cosmos SDK applications for interpretation, and in turn receives transactions from Cosmos SDK applications and submits them to the validators for confirmation.")])]),e._v(" "),a("p",[e._v("Applications that rely on the Tendermint consensus must implement concrete functions that support the ABCI interface. "),a("code",[e._v("BaseApp")]),e._v(" includes an implementation of ABCI so developers are not required to construct one.")]),e._v(" "),a("p",[e._v("ABCI itself includes methods such as "),a("code",[e._v("DeliverTx")]),e._v(", which delivers a transaction. The interpretation of the transaction is an application-level responsibility. Since a typical application supports more than one type of transaction, interpretation implies the need for a service router that will send the transaction to different interpreters based on the transaction type. "),a("code",[e._v("BaseApp")]),e._v(" includes a service router implementation.")]),e._v(" "),a("p",[e._v("As well as an ABCI implementation, "),a("code",[e._v("BaseApp")]),e._v(" also provides a state machine implementation. The implementation of a state machine is an application-level concern because the Tendermint consensus is application-agnostic. The Cosmos SDK state machine implementation contains an overall state that is subdivided into various substates. Subdivisions include module states, persistent states, and transient states. These are all implemented in "),a("code",[e._v("BaseApp")]),e._v(".")]),e._v(" "),a("p",[a("code",[e._v("BaseApp")]),e._v(" provides a secure interface between the application, the blockchain, and the state machine while defining as little as possible about the state machine.")]),e._v(" "),a("h2",{attrs:{id:"defining-an-application"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defining-an-application"}},[e._v("#")]),e._v(" Defining an application")]),e._v(" "),a("p",[e._v("Developers usually create a custom type for their application by referencing "),a("code",[e._v("BaseApp")]),e._v(" and declaring store keys, keepers, and a module manager, like this:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"undefined",base64:"dHlwZSBBcHAgc3RydWN0IHsKICAvLyByZWZlcmVuY2UgdG8gYSBCYXNlQXBwCiAgKmJhc2VhcHAuQmFzZUFwcAoKICAvLyBsaXN0IG9mIGFwcGxpY2F0aW9uIHN0b3JlIGtleXMKCiAgLy8gbGlzdCBvZiBhcHBsaWNhdGlvbiBrZWVwZXJzCgogIC8vIG1vZHVsZSBtYW5hZ2VyCn0K"}}),e._v(" "),a("p",[e._v("Extending the application with "),a("code",[e._v("BaseApp")]),e._v(" gives the former access to all the methods of "),a("code",[e._v("BaseApp")]),e._v(". Developers compose their custom application with the modules they want, while not having to concern themselves with the hard work of implementing the ABCI, the service routers, and the state management logic.")]),e._v(" "),a("h3",{attrs:{id:"type-definition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-definition"}},[e._v("#")]),e._v(" Type definition")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("BaseApp")]),e._v(" type holds many "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/v0.40.0-rc3/baseapp/baseapp.go#L46-L131",target:"_blank",rel:"noopener noreferrer"}},[e._v("important parameters"),a("OutboundLink")],1),e._v(" for any Cosmos SDK-based application.")]),e._v(" "),a("h4",{attrs:{id:"bootstrapping"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bootstrapping"}},[e._v("#")]),e._v(" Bootstrapping")]),e._v(" "),a("p",[e._v("Important parameters that are initialized during the bootstrapping of the application are:")]),e._v(" "),a("ul",[a("li",[a("p",[a("strong",[a("code",[e._v("CommitMultiStore")]),e._v(":")]),e._v(" this is the main store of the application, which holds the canonical state that is committed at the end of each block. This store is not cached, meaning it is not used to update the application's volatile (un-committed) states.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("CommitMultiStore")]),e._v(" is a store of stores. Each module of the application uses one or multiple "),a("code",[e._v("KVStores")]),e._v(" in the multistore to persist their subset of the state.")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("Database:")]),e._v(" the database is used by the "),a("code",[e._v("CommitMultiStore")]),e._v(" to handle data persistence.")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("Msg")]),e._v(" service router:")]),e._v(" the "),a("code",[e._v("msgServiceRouter")]),e._v(" facilitates the routing of "),a("code",[e._v("sdk.Msg")]),e._v(" requests to the appropriate module "),a("code",[e._v("Msg")]),e._v(" service for processing.")]),e._v(" "),a("p",[e._v("An "),a("code",[e._v("sdk.Msg")]),e._v(" here refers to the transaction component that needs to be processed by a service to update the application state, and not to the ABCI message, which implements the interface between the application and the underlying consensus engine.")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("gRPC Query Router:")]),e._v(" the "),a("code",[e._v("grpcQueryRouter")]),e._v(" facilitates the routing of gRPC queries to the appropriate module that will process them. These queries are not ABCI messages themselves. They are relayed to the relevant module's gRPC query service.")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("TxDecoder")]),e._v(":")]),e._v(" this is used to decode raw transaction bytes relayed by the underlying Tendermint engine.")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("ParamStore")]),e._v(":")]),e._v(" this is the parameter store used to get and set application consensus parameters.")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("AnteHandler")]),e._v(":")]),e._v(" this is used to handle signature verification, fee payment, and other pre-message execution checks when a transaction is received. It is executed during "),a("code",[e._v("CheckTx/RecheckTx")]),e._v(" and "),a("code",[e._v("DeliverTx")]),e._v(".")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("InitChainer")]),e._v(", "),a("code",[e._v("BeginBlocker")]),e._v(", and "),a("code",[e._v("EndBlocker")]),e._v(":")]),e._v(" these are the functions executed when the application receives the "),a("code",[e._v("InitChain")]),e._v(", "),a("code",[e._v("BeginBlock")]),e._v(", and "),a("code",[e._v("EndBlock")]),e._v(" ABCI messages from the underlying Tendermint engine.")])])]),e._v(" "),a("h4",{attrs:{id:"volatile-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-state"}},[e._v("#")]),e._v(" Volatile state")]),e._v(" "),a("p",[e._v("Parameters that define volatile states, cached states, include:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("checkState:")]),e._v(" this state is updated during "),a("code",[e._v("CheckTx")]),e._v(" and resets on "),a("code",[e._v("Commit")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("deliverState:")]),e._v(" this state is updated during "),a("code",[e._v("DeliverTx")]),e._v(" and set to nil on "),a("code",[e._v("Commit")]),e._v(". It gets re-initialized on "),a("code",[e._v("BeginBlock")]),e._v(".")])]),e._v(" "),a("h4",{attrs:{id:"consensus-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consensus-parameters"}},[e._v("#")]),e._v(" Consensus parameters")]),e._v(" "),a("p",[e._v("Consensus parameters define the overall consensus state:")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("voteInfos")]),e._v(":")]),e._v(" this parameter carries the list of validators whose pre-commit is missing, either because they did not vote or because the proposer did not include their vote. This information is carried by the context and can be used by the application for various things, like punishing absent validators.")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("minGasPrices")]),e._v(":")]),e._v(" this parameter defines the minimum gas prices accepted by the node. This is a local parameter, meaning each full-node can set a different "),a("code",[e._v("minGasPrices")]),e._v(". It is used in the "),a("code",[e._v("AnteHandler")]),e._v(" during "),a("code",[e._v("CheckTx")]),e._v(" mainly as a spam protection mechanism. The transaction enters the mempool only if the gas prices of the transaction are greater than one of the minimum gas prices in "),a("code",[e._v("minGasPrices")]),e._v(". If "),a("code",[e._v("minGasPrices == 1uatom,1photon")]),e._v(", the gas price of the transaction must be greater than "),a("code",[e._v("1uatom OR 1photon")]),e._v(".")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("appVersion")]),e._v(":")]),e._v(" version of the application set in the application's constructor function.")])]),e._v(" "),a("h3",{attrs:{id:"constructor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[e._v("#")]),e._v(" Constructor")]),e._v(" "),a("p",[e._v("Consider the following simple constructor:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"undefined",base64:"ZnVuYyBOZXdCYXNlQXBwKAogIG5hbWUgc3RyaW5nLCBsb2dnZXIgbG9nLkxvZ2dlciwgZGIgZGJtLkRCLCB0eERlY29kZXIgc2RrLlR4RGVjb2Rlciwgb3B0aW9ucyAuLi5mdW5jKCpCYXNlQXBwKSwKKSAqQmFzZUFwcCB7CgogIC8vIC4uLgp9Cg=="}}),e._v(" "),a("p",[e._v("The "),a("code",[e._v("BaseApp")]),e._v(" constructor function is pretty straightforward. Notice the possibility of providing additional "),a("code",[e._v("options")]),e._v(" to the "),a("code",[e._v("BaseApp")]),e._v(", which executes them in order. These options are generally setter functions for important parameters, like "),a("code",[e._v("SetPruning()")]),e._v(" to set pruning options, or "),a("code",[e._v("SetMinGasPrices()")]),e._v(" to set the node's min-gas-prices.")]),e._v(" "),a("p",[e._v("Developers can add additional options based on their application's needs.")]),e._v(" "),a("h2",{attrs:{id:"states"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#states"}},[e._v("#")]),e._v(" States")]),e._v(" "),a("p",[a("code",[e._v("BaseApp")]),e._v(" provides "),a("strong",[e._v("three primary states")]),e._v(". Two are volatile and one is persistent:")]),e._v(" "),a("ul",[a("li",[e._v("The persistent "),a("strong",[e._v("main")]),e._v(" state is the canonical state of the application.")]),e._v(" "),a("li",[e._v("The volatile states "),a("code",[e._v("checkState")]),e._v(" and "),a("code",[e._v("deliverState")]),e._v(" are used to handle transitions between main states during commits.")])]),e._v(" "),a("p",[e._v("There is one single "),a("code",[e._v("CommitMultiStore")]),e._v(", referred to as the main state or root state. "),a("code",[e._v("BaseApp")]),e._v(" derives the two volatile states using a mechanism called branching from this main state which is performed by the "),a("code",[e._v("CacheWrap")]),e._v(" function.")]),e._v(" "),a("h3",{attrs:{id:"initchain-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initchain-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("InitChain")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("The two volatile states "),a("code",[e._v("checkState")]),e._v(" and "),a("code",[e._v("deliverState")]),e._v(" are set by branching the root "),a("code",[e._v("CommitMultiStore")]),e._v(" during "),a("code",[e._v("InitChain")]),e._v(". Any subsequent reads and writes happen on branched versions of the "),a("code",[e._v("CommitMultiStore")]),e._v(". All reads to the branched store are cached to avoid unnecessary roundtrips to the main state.")]),e._v(" "),a("h3",{attrs:{id:"checktx-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checktx-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("CheckTx")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("checkState")]),e._v(", which is based on the last committed state from the root store, is used for any reads and writes during "),a("code",[e._v("CheckTx")]),e._v(". Here, you only execute the "),a("code",[e._v("AnteHandler")]),e._v(" and verify a service router exists for every message in the transaction.")]),e._v(" "),a("p",[e._v("Note that you branch the already branched "),a("code",[e._v("checkState")]),e._v(" when you execute the "),a("code",[e._v("AnteHandler")]),e._v(". This has the side effect that if the "),a("code",[e._v("AnteHandler")]),e._v(" fails, the state transitions will not be reflected in the "),a("code",[e._v("checkState")]),e._v(". "),a("code",[e._v("checkState")]),e._v(" is only updated on success.")]),e._v(" "),a("h3",{attrs:{id:"beginblock-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beginblock-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("BeginBlock")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("deliverState")]),e._v(" is set for use in subsequent "),a("code",[e._v("DeliverTx")]),e._v(" ABCI messages during "),a("code",[e._v("BeginBlock")]),e._v(". "),a("code",[e._v("deliverState")]),e._v(" is based on the last committed state from the root store, and is branched.")]),e._v(" "),a("p",[e._v("Note the "),a("code",[e._v("deliverState")]),e._v(" is set to nil on "),a("code",[e._v("Commit")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"delivertx-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delivertx-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("DeliverTx")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("The state flow for "),a("code",[e._v("DeliverTx")]),e._v(" is nearly identical to "),a("code",[e._v("CheckTx")]),e._v(", except state transitions occur on the "),a("code",[e._v("deliverState")]),e._v(" and messages in a transaction are executed. Similarly to "),a("code",[e._v("CheckTx")]),e._v(", state transitions occur on a doubly branched state, "),a("code",[e._v("deliverState")]),e._v(". Successful message execution results in writes being committed to "),a("code",[e._v("deliverState")]),e._v(".")]),e._v(" "),a("p",[e._v("If message execution fails, state transitions from the "),a("code",[e._v("AnteHandler")]),e._v(" are persisted.")]),e._v(" "),a("h3",{attrs:{id:"commit-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commit-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("Commit")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("All the state transitions that occurred in "),a("code",[e._v("deliverState")]),e._v(" are finally written during "),a("code",[e._v("Commit")]),e._v(" to the root "),a("code",[e._v("CommitMultiStore")]),e._v(", which in turn is committed to disk and results in a new application root hash. These state transitions are now considered final. The "),a("code",[e._v("checkState")]),e._v(" is finally set to the newly committed state and "),a("code",[e._v("deliverState")]),e._v(" is set to nil to be reset on "),a("code",[e._v("BeginBlock")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"paramstore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paramstore"}},[e._v("#")]),e._v(" "),a("code",[e._v("ParamStore")])]),e._v(" "),a("p",[e._v("During "),a("code",[e._v("InitChain")]),e._v(", the "),a("code",[e._v("RequestInitChain")]),e._v(" provides "),a("code",[e._v("ConsensusParams")]),e._v(", which contains parameters related to block execution such as maximum gas and size in addition to evidence parameters. If these parameters are non-nil, they are set in the "),a("code",[e._v("BaseApp")]),e._v("'s "),a("code",[e._v("ParamStore")]),e._v(". The "),a("code",[e._v("ParamStore")]),e._v(" is managed behind the scenes by an "),a("code",[e._v("x/params")]),e._v(" module subspace. This allows the parameters to be tweaked via on-chain governance.")]),e._v(" "),a("h2",{attrs:{id:"service-routers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-routers"}},[e._v("#")]),e._v(" Service routers")]),e._v(" "),a("p",[e._v("When messages and queries are received by the application, they must be routed as is appropriate to be processed. Routing is done via "),a("code",[e._v("BaseApp")]),e._v(", which holds a "),a("code",[e._v("msgServiceRouter")]),e._v(" for messages and a "),a("code",[e._v("grpcQueryRouter")]),e._v(" for queries.")]),e._v(" "),a("h3",{attrs:{id:"msg-service-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#msg-service-router"}},[e._v("#")]),e._v(" "),a("code",[e._v("Msg")]),e._v(" service router")]),e._v(" "),a("HighlightBox",{attrs:{type:"docs"}},[a("p",[e._v("Are you looking for more information on "),a("code",[e._v("BaseApp")]),e._v("? See the "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cosmos SDK documentation"),a("OutboundLink")],1),e._v(".")])]),e._v(" "),a("p",[e._v("The main ABCI messages that "),a("code",[e._v("BaseApp")]),e._v(" implements are "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#checktx",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("CheckTx")]),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/master/docs/core/baseapp.md#delivertx",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("DeliverTx")]),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("Other ABCI message handlers being implemented are:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("InitChain")])]),e._v(" "),a("li",[a("code",[e._v("BeginBlock")])]),e._v(" "),a("li",[a("code",[e._v("EndBlock")])]),e._v(" "),a("li",[a("code",[e._v("Commit")])]),e._v(" "),a("li",[a("code",[e._v("Info")])]),e._v(" "),a("li",[a("code",[e._v("Query")])])]),e._v(" "),a("h2",{attrs:{id:"next-up"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#next-up"}},[e._v("#")]),e._v(" Next up")]),e._v(" "),a("p",[e._v("In the "),a("RouterLink",{attrs:{to:"/academy/2-main-concepts/queries.html"}},[e._v("next section")]),e._v(", you can find information on queries, one of two primary objects handled by a module in the Cosmos SDK.")],1)],1)}),[],!1,null,null,null);t.default=o.exports}}]);