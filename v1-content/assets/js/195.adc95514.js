(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{812:function(e,t,o){"use strict";o.r(t);var n=o(1),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"understand-ibc-denoms-with-gaia"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#understand-ibc-denoms-with-gaia"}},[e._v("#")]),e._v(" Understand IBC Denoms with Gaia")]),e._v(" "),o("p",[e._v("One of the most powerful technologies when using the Cosmos SDK is the Interblockchain Communication Protocol (IBC). In the Cosmos Ecosystem, every blockchain is intended to be sovereign and application-specific. With IBC, every blockchain can connect to another blockchain using the IBC protocol. This communication protocol will eventually create a system of sovereign "),o("em",[e._v("and")]),e._v(" connected blockchains.")]),e._v(" "),o("h2",{attrs:{id:"introduction"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),o("p",[e._v("The most used feature of IBC is to send tokens from one blockchain to another. When sending a token to another blockchain, a token "),o("code",[e._v("voucher")]),e._v(" is generated on the other (target) blockchain.")]),e._v(" "),o("p",[e._v("Imagine two blockchains, blockchain A and blockchain B. In the beginning, you have your token on blockchain A.")]),e._v(" "),o("p",[o("tm-image",{attrs:{src:"/tutorials/understanding-ibc-denoms/ibc_token.png"}}),e._v(" "),o("em",[e._v("Sending token from blockchain A to blockchain B")])],1),e._v(" "),o("p",[e._v("The value that tokens represent can be transferred across chains, but the token itself cannot. When sending the tokens with IBC to another blockchain:")]),e._v(" "),o("ol",[o("li",[e._v("Blockchain A locks the tokens and relays proof to blockchain B.")]),e._v(" "),o("li",[e._v("Blockchain B mints its own representative tokens in the form of "),o("em",[e._v("voucher")]),e._v(" replacement tokens.")]),e._v(" "),o("li",[e._v("Blockchain B sends the voucher tokens back to blockchain A.")]),e._v(" "),o("li",[e._v("The voucher tokens are destroyed (burned) on blockchain B.")]),e._v(" "),o("li",[e._v("The locked tokens on blockchain A are unlocked.")])]),e._v(" "),o("p",[e._v("The only way to unlock the locked tokens on blockchain A is to send the voucher token back from blockchain B. The result is that the voucher token on blockchain B is burned. The burn process purposefully takes the tokens out of circulation.")]),e._v(" "),o("p",[e._v("In this tutorial, you learn the format of the voucher token on blockchain B. You learn what information the token voucher includes and what the token voucher looks like, and you learn how to make sense of them. The information of the token is described as an IBC denom. You can parse this IBC denom to receive information about the voucher and learn which blockchain the token voucher came from.")]),e._v(" "),o("p",[o("strong",[e._v("You will learn how to:")])]),e._v(" "),o("ul",[o("li",[e._v("Trace the IBC denom.")]),e._v(" "),o("li",[e._v("Understand how denoms work.")]),e._v(" "),o("li",[e._v("Find out which chain the token came from.")])]),e._v(" "),o("h2",{attrs:{id:"requirements"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#requirements"}},[e._v("#")]),e._v(" Requirements")]),e._v(" "),o("p",[e._v("Install the gaia binary:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"sh",base64:"JCBnaXQgY2xvbmUgaHR0cHM6Ly9naXRodWIuY29tL2Nvc21vcy9nYWlhLmdpdAokIGNkIGdhaWEKJCBnaXQgY2hlY2tvdXQgdjUuMC4wCiQgbWFrZSBpbnN0YWxsCgokIGdhaWFkIHZlcnNpb24K"}}),e._v(" "),o("p",[e._v("The output of "),o("code",[e._v("gaiad version")]),e._v(" should print:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"undefined",base64:"djUuMC4wCg=="}}),e._v(" "),o("h2",{attrs:{id:"what-is-this-ibc-denom"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#what-is-this-ibc-denom"}},[e._v("#")]),e._v(" What Is This IBC Denom")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("voucher")]),e._v(" tokens introduced in the asset transfer are called IBC Denominations (IBC denom). The voucher tokens are the result of a token transfer using IBC from one blockchain to another. The format of the voucher token is:")]),e._v(" "),o("p",[o("code",[e._v("ibc/DENOMHASH")]),e._v(".")]),e._v(" "),o("p",[e._v("Imagine that you've received a new "),o("code",[e._v("ibc/")]),e._v(" token on blockchain B where you initially held "),o("code",[e._v("samoleans")]),e._v(" and "),o("code",[e._v("stake")]),e._v(" token.")]),e._v(" "),o("p",[e._v("Your balance now looks like:")]),e._v(" "),o("p",[o("code",[e._v("1000000ibc/CDC4587874B85BEA4FCEC3CEA5A1195139799A1FEE711A07D972537E18FDA39D,100000000000samoleans,99999977256stake")])]),e._v(" "),o("p",[e._v("Just like "),o("code",[e._v("samoleans")]),e._v(" or "),o("code",[e._v("stake")]),e._v(", "),o("code",[e._v("ibc/CDC458787...")]),e._v(" is the denomination (denom) of the token received from IBC. After "),o("code",[e._v("ibc/CDC458787...")]),e._v(" is a hash of the denom, the IBC port, and the channel.")]),e._v(" "),o("p",[e._v("Why is "),o("code",[e._v("CDC458787...")]),e._v(" a hash?")]),e._v(" "),o("ul",[o("li",[e._v("The hash contains paths that track the token on multiple hops from other blockchains to your account.")]),e._v(" "),o("li",[e._v("This path could potentially be unbearably long when directly printing the path.")]),e._v(" "),o("li",[e._v("The Cosmos SDK has a 64-character limit on the denomination of the token.")])]),e._v(" "),o("p",[e._v("The tradeoff of using a hash is that you must query a node to find out what the actual path and denomination is. This query is called the "),o("em",[e._v("denomtrace")]),e._v(".")]),e._v(" "),o("p",[e._v("Follow along with the "),o("code",[e._v("gaiad")]),e._v(" subcommands to query the denom and learn about the channel the tokens came from.")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"sh",base64:"JCBnYWlhZCBxdWVyeSBpYmMtdHJhbnNmZXIgZGVub20tdHJhY2UgQ0RDNDU4Nzg3NEI4NUJFQTRGQ0VDM0NFQTVBMTE5NTEzOTc5OUExRkVFNzExQTA3RDk3MjUzN0UxOEZEQTM5RCAtLW5vZGUgaHR0cHM6Ly9ycGMudGVzdG5ldC5jb3Ntb3MubmV0d29yazo0NDMK"}}),e._v(" "),o("p",[e._v("Response:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"undefined",base64:"ZGVub21fdHJhY2U6CiAgYmFzZV9kZW5vbTogbW9vbgogIHBhdGg6IHRyYW5zZmVyL2NoYW5uZWwtMTQK"}}),e._v(" "),o("p",[e._v("From the command output, you now know that there is an IBC port "),o("code",[e._v("transfer")]),e._v(" and channel "),o("code",[e._v("channel-14")]),e._v(". But to know the IBC light client behind the port and channel, you need to perform another query.")]),e._v(" "),o("p",[e._v("Why is it called a light client? Because it is a light client of the "),o("em",[e._v("other")]),e._v(" chain, keeping track of its blockhashes. The "),o("code",[e._v("ibc channel client-state transfer")]),e._v(" command  explains the details of the denom path.")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"sh",base64:"JCBnYWlhZCBxdWVyeSBpYmMgY2hhbm5lbCBjbGllbnQtc3RhdGUgdHJhbnNmZXIgY2hhbm5lbC0xNCAtLW5vZGUgaHR0cHM6Ly9ycGMuY29zbW9zLm5ldHdvcms6NDQzCg=="}}),e._v(" "),o("p",[e._v("Response:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"undefined",base64:"Y2xpZW50X2lkOiAwNy10ZW5kZXJtaW50LTE4CmNsaWVudF9zdGF0ZToKICAnQHR5cGUnOiAvaWJjLmxpZ2h0Y2xpZW50cy50ZW5kZXJtaW50LnYxLkNsaWVudFN0YXRlCiAgYWxsb3dfdXBkYXRlX2FmdGVyX2V4cGlyeTogdHJ1ZQogIGFsbG93X3VwZGF0ZV9hZnRlcl9taXNiZWhhdmlvdXI6IHRydWUKICBjaGFpbl9pZDogbWFycwogIGZyb3plbl9oZWlnaHQ6CiAgICByZXZpc2lvbl9oZWlnaHQ6ICZxdW90OzAmcXVvdDsKICAgIHJldmlzaW9uX251bWJlcjogJnF1b3Q7MCZxdW90OwogIGxhdGVzdF9oZWlnaHQ6CiAgICByZXZpc2lvbl9oZWlnaHQ6ICZxdW90OzIyMDcmcXVvdDsKICAgIHJldmlzaW9uX251bWJlcjogJnF1b3Q7MCZxdW90OwogIG1heF9jbG9ja19kcmlmdDogNjAwcwogIHByb29mX3NwZWNzOgogIC0gaW5uZXJfc3BlYzoKICAgICAgY2hpbGRfb3JkZXI6CiAgICAgIC0gMAogICAgICAtIDEKICAgICAgY2hpbGRfc2l6ZTogMzMKICAgICAgZW1wdHlfY2hpbGQ6IG51bGwKICAgICAgaGFzaDogU0hBMjU2CiAgICAgIG1heF9wcmVmaXhfbGVuZ3RoOiAxMgogICAgICBtaW5fcHJlZml4X2xlbmd0aDogNAogICAgbGVhZl9zcGVjOgogICAgICBoYXNoOiBTSEEyNTYKICAgICAgbGVuZ3RoOiBWQVJfUFJPVE8KICAgICAgcHJlZml4OiBBQT09CiAgICAgIHByZWhhc2hfa2V5OiBOT19IQVNICiAgICAgIHByZWhhc2hfdmFsdWU6IFNIQTI1NgogICAgbWF4X2RlcHRoOiAwCiAgICBtaW5fZGVwdGg6IDAKICAtIGlubmVyX3NwZWM6CiAgICAgIGNoaWxkX29yZGVyOgogICAgICAtIDAKICAgICAgLSAxCiAgICAgIGNoaWxkX3NpemU6IDMyCiAgICAgIGVtcHR5X2NoaWxkOiBudWxsCiAgICAgIGhhc2g6IFNIQTI1NgogICAgICBtYXhfcHJlZml4X2xlbmd0aDogMQogICAgICBtaW5fcHJlZml4X2xlbmd0aDogMQogICAgbGVhZl9zcGVjOgogICAgICBoYXNoOiBTSEEyNTYKICAgICAgbGVuZ3RoOiBWQVJfUFJPVE8KICAgICAgcHJlZml4OiBBQT09CiAgICAgIHByZWhhc2hfa2V5OiBOT19IQVNICiAgICAgIHByZWhhc2hfdmFsdWU6IFNIQTI1NgogICAgbWF4X2RlcHRoOiAwCiAgICBtaW5fZGVwdGg6IDAKICB0cnVzdF9sZXZlbDoKICAgIGRlbm9taW5hdG9yOiAmcXVvdDszJnF1b3Q7CiAgICBudW1lcmF0b3I6ICZxdW90OzEmcXVvdDsKICB0cnVzdGluZ19wZXJpb2Q6IDEyMDk2MDBzCiAgdW5ib25kaW5nX3BlcmlvZDogMTgxNDQwMHMKICB1cGdyYWRlX3BhdGg6CiAgLSB1cGdyYWRlCiAgLSB1cGdyYWRlZElCQ1N0YXRlCg=="}}),e._v(" "),o("p",[e._v("That's a lot of information, but it doesn't answer the question: how do you know if this IBC client can be relied upon?")]),e._v(" "),o("h3",{attrs:{id:"the-chain-id-and-the-client-id"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#the-chain-id-and-the-client-id"}},[e._v("#")]),e._v(" The Chain ID and the Client ID")]),e._v(" "),o("p",[e._v("Anybody can start a chain with the same chain ID. However, the IBC client ID is generated by the "),o("a",{attrs:{href:"https://github.com/cosmos/ibc-go/blob/e012a4af5614f8774bcb595962012455667db2cf/modules/core/02-client/keeper/keeper.go#L56",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cosmos SDK IBC Keeper module"),o("OutboundLink")],1),e._v(" (ICS-02 does not specify a standard for IBC client IDs). A Chain Name Service and the not-so-decentralized Github chain-registrar repo can verify the combination of the chain ID and the client ID. Both the Chain Name Service and the chain-registrar repo are under development and are considered experimental.")]),e._v(" "),o("h3",{attrs:{id:"ensure-the-ibc-client-isn-t-expired"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#ensure-the-ibc-client-isn-t-expired"}},[e._v("#")]),e._v(" Ensure the IBC Client Isn't Expired")]),e._v(" "),o("p",[e._v("In the event that Tendermint consensus fails (if >1/3 of validators produce a conflicting block), "),o("em",[e._v("and")]),e._v(" proof of this consensus failure is submitted on-chain, the IBC client becomes frozen with a "),o("code",[e._v("frozen_height")]),e._v(" that is nonzero. In the previous example, the output of "),o("code",[e._v("gaiad query ibc channel client-state")]),e._v(" confirms the client status and you know the IBC client is not expired.")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("latest_height.revision_height")]),e._v(" is the block height when the IBC client was last updated. To ensure that the block height is still up to date, you would have to query the blockchain itself for the block height 2207, and ensure that the timestamp of that block + the "),o("code",[e._v("trusting_period")]),e._v(" of 1209600s/336h/14d is after the current time.")]),e._v(" "),o("p",[e._v("For example, you can verify the IBC client status using the query:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"sh",base64:"JCBnYWlhZCBxdWVyeSBibG9jayA1MjAwNzkyIC0tbm9kZSBodHRwczovL3JwYy5jb3Ntb3MubmV0d29yazo0NDMK"}}),e._v(" "),o("h2",{attrs:{id:"find-the-path-of-another-blockchain"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#find-the-path-of-another-blockchain"}},[e._v("#")]),e._v(" Find the Path of Another Blockchain")]),e._v(" "),o("p",[e._v("Being able to list all possible blockchain paths is still an unsolved problem.")]),e._v(" "),o("p",[e._v("Any created blockchain can create a new "),o("code",[e._v("channel")]),e._v(" to another blockchain without revealing too much of its information.")]),e._v(" "),o("p",[e._v("Currently, channels must communicate with each other using a person-to-person protocol to be trustable. This person-to-person communication protocol uses an IBC denom so you can identify which tokens to accept for an app.")]),e._v(" "),o("p",[e._v("One approach to solve this problem is to use a centralized or decentralized database of chain IDs and their nodes.  There are two solutions under development:")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("Chain Name Service (decentralized):")]),e._v(" "),o("p",[e._v("The "),o("a",{attrs:{href:"https://github.com/tendermint/cns",target:"_blank",rel:"noopener noreferrer"}},[e._v("CNS"),o("OutboundLink")],1),e._v(" aims to be a Cosmos SDK module that the Cosmos Hub will one day run. As a hub through which cross-chain transactions go, it only makes sense for the Cosmos Hub to host the critical information on how to reach the other chain IDs. CNS is still new and under development.")])]),e._v(" "),o("li",[o("p",[e._v("Cosmos Registry (semi-decentralized):")]),e._v(" "),o("p",[e._v("The "),o("a",{attrs:{href:"https://github.com/cosmos/registry",target:"_blank",rel:"noopener noreferrer"}},[e._v("github.com/cosmos/registry"),o("OutboundLink")],1),e._v(" repo is a stopgap solution. Each chain ID has a folder describing its genesis and a list of peers. To claim their chain ID, a blockchain operator must fork the "),o("code",[e._v("registry")]),e._v(" repo, create a branch with their chain ID, and submit a pull request to include their chain ID in the official "),o("code",[e._v("cosmos/registry")]),e._v(" of chain IDs.")]),e._v(" "),o("p",[e._v("Every chain ID is represented by a folder, and within that folder a "),o("code",[e._v("peers.json")]),e._v(" file contains a list of nodes that you can connect to.")])]),e._v(" "),o("li",[o("p",[e._v("Cosmos Registrar (semi-decentralized):")]),e._v(" "),o("p",[e._v("The "),o("a",{attrs:{href:"https://github.com/apeunit/cosmos-registrar",target:"_blank",rel:"noopener noreferrer"}},[e._v("cosmos-registrar"),o("OutboundLink")],1),e._v(" is a tool that was started by Jack Zampolin and further developed by Ape Unit. The cosmos-registrar automates claiming and updating a chain ID. In this case, updating a chain ID means committing a fresh peerlist to the GitHub repository. This commit should be run with a cronjob. Its state is best described as v1.0, so go ahead and report any bugs as Github issues.")])])]),e._v(" "),o("p",[e._v("Choose the approach that best suits you and your use case.")])],1)}),[],!1,null,null,null);t.default=a.exports}}]);