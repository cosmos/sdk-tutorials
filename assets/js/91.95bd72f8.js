(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{710:function(e,t,a){"use strict";a.r(t);var n=a(1),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"relaying-with-ibc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#relaying-with-ibc"}},[e._v("#")]),e._v(" Relaying With IBC")]),e._v(" "),a("HighlightBox",{attrs:{type:"learning"}},[a("p",[e._v("In this section, you will learn how relayers fit into the Inter-Blockchain Communication Protocol (IBC).")])]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/3-ibc/images/ibcoverview.png"}})],1),e._v(" "),a("p",[e._v("It is useful to briefly recap what relaying is and why it is important. IBC aims to offer blockchains a protocol to enable reliable, secure, and permissionless transfer of packets of data. The protocol is agnostic concerning the data, paving the way for application developers to develop a range of possible interchain services (fungible and non-fungible token transfers are an obvious candidate, but also arbitrary cross-chain messaging via "),a("a",{attrs:{href:"https://interchain-io.medium.com/welcome-to-the-ibc-gang-lets-talk-2f5b95133a5d",target:"_blank",rel:"noopener noreferrer"}},[e._v("interchain accounts"),a("OutboundLink")],1),e._v(").")]),e._v(" "),a("p",[e._v("On a high level, this works as follows. A module on a source chain wants to send a packet to a destination chain. It submits a message to the source chain that stores a commitment proof on-chain and logs an event with the packet information. With this information and the proof, you can submit a message to the IBC client on the destination chain, which will verify the proof and (if successful) store a receipt on-chain and have the receiving module execute the required actions according to the packet data. The acknowledgement and timeout functionality has been discussed "),a("RouterLink",{attrs:{to:"/academy/3-ibc/3-channels.html"}},[e._v("previously")]),e._v(".")],1),e._v(" "),a("p",[e._v("There are two important considerations to make based on this flow. First, on the receiving chain, you need to verify the commitment proof on the source chain. This is why a light client is used to track the state of the counterparty chain (in an efficient way). Second, blockchains cannot directly communicate with one another. So how do the proof and packet data arrive at the destination chain to continue the flow described above?")]),e._v(" "),a("p",[e._v("This is where the relayer operators come into the picture: they ensure the relaying of the packets over network infrastructure. "),a("strong",[e._v("Relayers have access to full nodes of both source and destination chains, where they can query and submit messages.")]),e._v(" They listen in on the chains they service for events that require an IBC packet to be sent. They run relayer software that enables them to rebuild the packet along with the proof and submit this to the destination chain. A similar process then happens upon storing the receipt on the destination chain, causing the acknowledgement message to be sent to the source.")]),e._v(" "),a("p",[e._v("The relayers are a crucial part of the IBC infrastructure. Remember that relaying is permissionless and trustless (the light client verification provides the trust).")]),e._v(" "),a("h2",{attrs:{id:"what-is-needed-to-relay"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-needed-to-relay"}},[e._v("#")]),e._v(" What is needed to relay?")]),e._v(" "),a("p",[e._v("Before moving on to look at specific implementations of relayer software, understand the general set of requirements or functionality that relayer software needs to have.")]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("Information about the chains:")]),e._v(" a relayer will relay packets between a pair of chains, so it requires some information about these chains.")]),e._v(" "),a("li",[a("strong",[e._v("Information about the path:")]),e._v(" once you know the chains you are relaying on, the next requirement is to know which path to relay on. Remember, the IBC protocol has three main layers of abstraction: the (light) clients, connections, and channels (and ports).")]),e._v(" "),a("li",[a("strong",[e._v("A private key:")]),e._v(" to a relayer operator address on all chains that you want to relay on. Remember that a relayer needs to submit IBC messages to the chains they are relaying between (Receive, Acknowledge, and Timeout), which typically require a fee. Therefore the relayer operator address needs to have funds.")]),e._v(" "),a("li",[a("strong",[e._v("Ability to query and submit messages (or transactions):")]),e._v(" as mentioned already, chains do not communicate directly with one another. It is the relayer's job to listen for events related to a packet commitment. They can do this by subscribing to these events via the CometBFT WebSocket, and querying the proofs via the CometBFT RPC endpoint. You also can query and create through transactions clients, connections, and channels. There are transactions to update and upgrade light clients, submit a notice of misbehavior, and those that allow you to relay packets and acknowledgements or timeouts. For more detail, you will look at the command lists for the Go and Hermes relayers next.")])]),e._v(" "),a("HighlightBox",{attrs:{type:"tip"}},[a("p",[e._v("With the current architecture, relayers use the CometBFT RPC endpoint to query for the commitment proof, as the proofs that are required to submit IBC messages to the counterparty chain (more specifically the light client) for verification are not available via gRPC. Relayer calls can put significant pressure on the RPC endpoints of the nodes, which is one of the main bottlenecks currently in production. Because the CometBFT RPC is single-threaded, large amounts of relayer calls may cause the node to run out of sync, requiring regular resets.")])]),e._v(" "),a("h3",{attrs:{id:"configuration-file"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#configuration-file"}},[e._v("#")]),e._v(" Configuration file")]),e._v(" "),a("p",[e._v("The information and parameters about the chains, paths, and the name of the relayer private key to sign the messages can generally be found in a configuration file, the "),a("em",[e._v("config")]),e._v(". You will look at template configs for the Hermes and Go relayer later, but generally, config files are the place to initialize, add, or edit information required for relaying.")]),e._v(" "),a("h3",{attrs:{id:"chain-registry"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chain-registry"}},[e._v("#")]),e._v(" Chain registry")]),e._v(" "),a("p",[e._v("When you have the template for the config file of the relayer software you are using, where can you find the information that it needs? The "),a("a",{attrs:{href:"https://github.com/cosmos/chain-registry",target:"_blank",rel:"noopener noreferrer"}},[e._v("chain-registry Github repository"),a("OutboundLink")],1),e._v(" provides detailed parameters about chains and their assets, and recently a schema was added to submit IBC data. This new addition saves you from having to look up path information or canonical channels on "),a("a",{attrs:{href:"https://www.mintscan.io/cosmos/relayers",target:"_blank",rel:"noopener noreferrer"}},[e._v("Mintscan"),a("OutboundLink")],1),e._v(" or "),a("a",{attrs:{href:"https://mapofzones.com/?testnet=false&period=24&tableOrderBy=ibcVolume&tableOrderSort=desc",target:"_blank",rel:"noopener noreferrer"}},[e._v("Map of Zones"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("The following is an example of the IBC data between Juno and Osmosis:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"json",base64:"ewogICZxdW90OyRzY2hlbWEmcXVvdDs6ICZxdW90Oy4uL2liY19kYXRhLnNjaGVtYS5qc29uJnF1b3Q7LAogICZxdW90O2NoYWluLTEmcXVvdDs6IHsKICAgICZxdW90O2NoYWluLW5hbWUmcXVvdDs6ICZxdW90O2p1bm8mcXVvdDssCiAgICAmcXVvdDtjbGllbnQtaWQmcXVvdDs6ICZxdW90OzA3LXRlbmRlcm1pbnQtMCZxdW90OywKICAgICZxdW90O2Nvbm5lY3Rpb24taWQmcXVvdDs6ICZxdW90O2Nvbm5lY3Rpb24tMCZxdW90OwogIH0sCiAgJnF1b3Q7Y2hhaW4tMiZxdW90OzogewogICAgJnF1b3Q7Y2hhaW4tbmFtZSZxdW90OzogJnF1b3Q7b3Ntb3NpcyZxdW90OywKICAgICZxdW90O2NsaWVudC1pZCZxdW90OzogJnF1b3Q7MDctdGVuZGVybWludC0xNDU3JnF1b3Q7LAogICAgJnF1b3Q7Y29ubmVjdGlvbi1pZCZxdW90OzogJnF1b3Q7Y29ubmVjdGlvbi0xMTQyJnF1b3Q7CiAgfSwKICAmcXVvdDtjaGFubmVscyZxdW90OzogWwogICAgewogICAgICAmcXVvdDtjaGFpbi0xJnF1b3Q7OiB7CiAgICAgICAgJnF1b3Q7Y2hhbm5lbC1pZCZxdW90OzogJnF1b3Q7Y2hhbm5lbC0wJnF1b3Q7LAogICAgICAgICZxdW90O3BvcnQtaWQmcXVvdDs6ICZxdW90O3RyYW5zZmVyJnF1b3Q7CiAgICAgIH0sCiAgICAgICZxdW90O2NoYWluLTImcXVvdDs6IHsKICAgICAgICAmcXVvdDtjaGFubmVsLWlkJnF1b3Q7OiAmcXVvdDtjaGFubmVsLTQyJnF1b3Q7LAogICAgICAgICZxdW90O3BvcnQtaWQmcXVvdDs6ICZxdW90O3RyYW5zZmVyJnF1b3Q7CiAgICAgIH0sCiAgICAgICZxdW90O29yZGVyaW5nJnF1b3Q7OiAmcXVvdDt1bm9yZGVyZWQmcXVvdDssCiAgICAgICZxdW90O3ZlcnNpb24mcXVvdDs6ICZxdW90O2ljczIwLTEmcXVvdDssCiAgICAgICZxdW90O3RhZ3MmcXVvdDs6IHsKICAgICAgICAmcXVvdDtzdGF0dXMmcXVvdDs6ICZxdW90O2xpdmUmcXVvdDssCiAgICAgICAgJnF1b3Q7cHJlZmVycmVkJnF1b3Q7OiB0cnVlLAogICAgICAgICZxdW90O2RleCZxdW90OzogJnF1b3Q7b3Ntb3NpcyZxdW90OwogICAgICB9CiAgICB9CiAgXQp9Cg=="}}),e._v(" "),a("p",[e._v("The Go relayer has built-in functionality to fetch chain and path information from the chain registry. Hermes has this functionality on its roadmap. You will look at both relayers in more detail in the next sections.")]),e._v(" "),a("h2",{attrs:{id:"faq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[e._v("#")]),e._v(" FAQ")]),e._v(" "),a("p",[e._v("The Interchain is developing fast, and minor changes can cause big problems for inexperienced users. Luckily you have the option to make direct contact with developers through the "),a("a",{attrs:{href:"https://discord.com/invite/cosmosnetwork",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cosmos Developer Discord"),a("OutboundLink")],1),e._v(". There you can find the "),a("strong",[e._v("developers")]),e._v(" forum and use the "),a("code",[e._v("run-infrastructure")]),e._v(" tag in case you need help.")]),e._v(" "),a("HighlightBox",{attrs:{type:"synopsis"}},[a("p",[e._v("To summarize, this section has explored:")]),e._v(" "),a("ul",[a("li",[e._v("How IBC provides blockchain developers a data-agnostic protocol for reliable, secure, and permissionless packet transfer, which enables the possibility of various interchain services, from basic cross-chain messaging to fungible and non-fungible token transfers and more.")]),e._v(" "),a("li",[e._v("How, on a high level, a module sends a packet to a destination chain by first causing the source chain to store a commitment proof on-chain and log an event with the packet information; this is communicated to the destination chain for verification, which then stores a receipt on-chain and has the receiving module execute the actions required by the packet data.")]),e._v(" "),a("li",[e._v("How in the process described the destination chain relies on a light client to efficiently track the state of the counterparty chain.")]),e._v(" "),a("li",[e._v("How relayer operators perform the conveying of data packets through the network by having access to full nodes of both source and destination chains, where they can query and submit messages, listen in for events requiring an IBC packet to be sent, and rebuild the packet and proof for submission and receipt at its destination.")]),e._v(" "),a("li",[e._v("How information and parameters about the chains, paths, and the name of the relayer private key to sign the messages can generally be found in a configuration file, or "),a("em",[e._v("config")]),e._v(".")])])])],1)}),[],!1,null,null,null);t.default=o.exports}}]);