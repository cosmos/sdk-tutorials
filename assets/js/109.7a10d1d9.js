(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{726:function(e,t,a){"use strict";a.r(t);var n=a(1),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"transport-authentication-and-ordering-layer-channels"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transport-authentication-and-ordering-layer-channels"}},[e._v("#")]),e._v(" Transport, Authentication, and Ordering Layer - Channels")]),e._v(" "),a("HighlightBox",{attrs:{type:"learning"}},[a("p",[e._v("In this section, you will:")]),e._v(" "),a("ul",[a("li",[e._v("Establish a channel.")]),e._v(" "),a("li",[e._v("Learn about the application packet flow.")])])]),e._v(" "),a("p",[e._v("Connections and clients comprise the main components of the transport layer in IBC. However, application to application communication in IBC is conducted over "),a("strong",[e._v("channels")]),e._v(", which route between an application module such as the module which handles Interchain Standard (ICS) 20 token transfers on one chain, and the corresponding application module on another one. These applications are namespaced by "),a("strong",[e._v("port identifiers")]),e._v(" such as 'transfer' for ICS-20 token transfers.")]),e._v(" "),a("HighlightBox",{attrs:{type:"note"}},[a("p",[e._v("Note that it is possible to have either a "),a("em",[e._v("symmetric")]),e._v(" case, where the application logic is independent of the direction of the packet being sent, or an "),a("em",[e._v("asymmetric")]),e._v(" case, where packets should only be sent in one direction (or the logic can be different depending on the send direction). It makes sense (but is not imposed) to use the same port ID on both application modules in the symmetric case, and different port IDs on either chain in the asymmetric.\n"),a("br"),a("br"),e._v("\nFor example, in the case of interchain accounts, there are two different port IDs for the host and controller submodules: in the interchain accounts module, "),a("code",[e._v("icahost")]),e._v(" is the default port ID that the host submodule binds to, whereas "),a("code",[e._v("icacontroller-...")]),e._v(" is the default port prefix that the controller submodule binds to.")])]),e._v(" "),a("p",[e._v("Contrary to the core IBC transport layer logic, which handles only verification, ordering, and all around basic packet correctness, the application layer over channels handles only the application-specific logic which interprets the packets that have been sent over the transport layer. This concern separation between transport and application layer in IBC is similar to the concern separation between CometBFT's consensus layer (consensus, mempool, ordering of transactions) and ABCI layer (process of those transaction bytes).")]),e._v(" "),a("HighlightBox",{attrs:{type:"remember"}},[a("p",[e._v("A connection may have any number of associated channels. However, each channel is associated with only one connection ID, which indicates which light client it is secured by, and one port ID which indicates the application that it is connected to.")])]),e._v(" "),a("p",[e._v("As mentioned above, channels are payload agnostic. The application modules sending and receiving IBC packets decide how to interpret and act upon the incoming packet data, and use their own application logic and handlers to determine which state transitions to apply according to the data contained in each received packet.")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v("Remember the abbreviation "),a("em",[e._v("IBC/TAO")]),e._v(" where the "),a("em",[e._v("O")]),e._v(" represents "),a("em",[e._v("Ordering")]),e._v(". There are currently two different types of channels in terms of ordering:")]),e._v(" "),a("ul",[a("li",[e._v("An "),a("strong",[e._v("ordered channel")]),e._v(" is "),a("em",[e._v("a channel where packets are delivered exactly in the order in which they were sent")]),e._v(".")]),e._v(" "),a("li",[e._v("An "),a("strong",[e._v("unordered channel")]),e._v(" is "),a("em",[e._v("a channel where packets can be delivered in any order")]),e._v(", which may differ from the order in which they were sent.")])])]),e._v(" "),a("h2",{attrs:{id:"establishing-a-channel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#establishing-a-channel"}},[e._v("#")]),e._v(" Establishing a channel")]),e._v(" "),a("p",[e._v("Similarly to how connections are established, "),a("strong",[e._v("channels are established through a four-way handshake")]),e._v(", in which each step is initiated by a relayer:")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/3-ibc/images/channelhandshake.png"}})],1),e._v(" "),a("ol",[a("li",[a("code",[e._v("ChanOpenInit")]),e._v(": will set the chain A into "),a("code",[e._v("INIT")]),e._v(" state. This will call "),a("code",[e._v("OnChanOpenInit")]),e._v(" so application A can apply the custom callback that it has set on "),a("code",[e._v("INIT")]),e._v(", e.g. check if the port has been set correctly, the channel is indeed unordered/ordered as expected, etc. An application version is also proposed in this step.")]),e._v(" "),a("li",[a("code",[e._v("ChanOpenTry")]),e._v(": will set chain B into "),a("code",[e._v("TRY")]),e._v(" state. It will call "),a("code",[e._v("OnChanOpenTry")]),e._v(" so application B can apply its custom "),a("code",[e._v("TRY")]),e._v(" callback. Application version negotiation also happens during this step.")]),e._v(" "),a("li",[a("code",[e._v("ChanOpenAck")]),e._v(": will set the chain A into "),a("code",[e._v("OPEN")]),e._v(" state. This will call "),a("code",[e._v("OnChanOpenAck")]),e._v(" which will be implemented by the application. Application version negotiation is finalised during this step.")]),e._v(" "),a("li",[a("code",[e._v("ChanOpenConfirm")]),e._v(": will set chain B into "),a("code",[e._v("OPEN")]),e._v(" state so application B can apply its "),a("code",[e._v("CONFIRM")]),e._v(" logic.")])]),e._v(" "),a("HighlightBox",{attrs:{type:"note"}},[a("p",[e._v('"Crossing hellos" refers to a situation when both chains attempt the same handshake step at the same time.\n'),a("br"),a("br"),e._v("\nCrossing hellos have been removed from ibc-go v4 onward, as referenced in "),a("a",{attrs:{href:"https://github.com/cosmos/ibc-go/pull/1317",target:"_blank",rel:"noopener noreferrer"}},[e._v("this PR"),a("OutboundLink")],1),e._v(". The "),a("code",[e._v("PreviousChannelId")]),e._v(" in "),a("code",[e._v("MsgChannelOpenTry")]),e._v(" has been deprecated.")])]),e._v(" "),a("p",[e._v("Similarly, there are also "),a("a",{attrs:{href:"https://github.com/cosmos/ibc/tree/main/spec/core/ics-004-channel-and-packet-semantics#closing-handshake",target:"_blank",rel:"noopener noreferrer"}},[e._v("callbacks for the closing of channels"),a("OutboundLink")],1),e._v(". However, it is up to the application developers to decide if it makes sense for users to be able to trigger the closing of a channel. For token transfers for example, this is not desirable due to the risk of locking liquidity on a closed channel, hence that is "),a("a",{attrs:{href:"https://github.com/cosmos/ibc-go/blob/v7.0.0/modules/apps/transfer/ibc_module.go#L151",target:"_blank",rel:"noopener noreferrer"}},[e._v("why this feature has been disallowed in the canonical "),a("code",[e._v("transfer")]),e._v(" module"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"example-code-channelopeninit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example-code-channelopeninit"}},[e._v("#")]),e._v(" Example code: "),a("code",[e._v("ChannelOpenInit")])]),e._v(" "),a("p",[e._v("You can find the implementation of "),a("code",[e._v("ChannelOpenInit")]),e._v(" in core IBC's "),a("a",{attrs:{href:"https://github.com/cosmos/ibc-go/blob/v7.0.0/modules/core/keeper/msg_server.go#L166",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("msg_server.go")]),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("The important part to note in this code snippet is that an application module has capabilities for the requested port. Therefore, an application module can only use a channel and port if the application owns the capability for that port and the module which attempting to open a channel is the module we have granted capabilities to in "),a("code",[e._v("app.go")]),e._v(":")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"Ly8gQ2hhbm5lbE9wZW5Jbml0IGRlZmluZXMgYSBycGMgaGFuZGxlciBtZXRob2QgZm9yIE1zZ0NoYW5uZWxPcGVuSW5pdC4KLy8gQ2hhbm5lbE9wZW5Jbml0IHdpbGwgcGVyZm9ybSAwNC1jaGFubmVsIGNoZWNrcywgcm91dGUgdG8gdGhlIGFwcGxpY2F0aW9uCi8vIGNhbGxiYWNrLCBhbmQgd3JpdGUgYW4gT3BlbkluaXQgY2hhbm5lbCBpbnRvIHN0YXRlIHVwb24gc3VjY2Vzc2Z1bCBleGVjdXRpb24uCmZ1bmMgKGsgS2VlcGVyKSBDaGFubmVsT3BlbkluaXQoZ29DdHggY29udGV4dC5Db250ZXh0LCBtc2cgKmNoYW5uZWx0eXBlcy5Nc2dDaGFubmVsT3BlbkluaXQpICgqY2hhbm5lbHR5cGVzLk1zZ0NoYW5uZWxPcGVuSW5pdFJlc3BvbnNlLCBlcnJvcikgewogICAgY3R4IDo9IHNkay5VbndyYXBTREtDb250ZXh0KGdvQ3R4KQoKICAgIC8vIExvb2t1cCBtb2R1bGUgYnkgcG9ydCBjYXBhYmlsaXR5CiAgICBtb2R1bGUsIHBvcnRDYXAsIGVyciA6PSBrLlBvcnRLZWVwZXIuTG9va3VwTW9kdWxlQnlQb3J0KGN0eCwgbXNnLlBvcnRJZCkKICAgIGlmIGVyciAhPSBuaWwgewogICAgICAgIHJldHVybiBuaWwsIHNka2Vycm9ycy5XcmFwKGVyciwgJnF1b3Q7Y291bGQgbm90IHJldHJpZXZlIG1vZHVsZSBmcm9tIHBvcnQtaWQmcXVvdDspCiAgICB9CgogICAgLi4uCgogICAgLy8gUGVyZm9ybSAwNC1jaGFubmVsIHZlcmlmaWNhdGlvbgogICAgY2hhbm5lbElELCBjYXAsIGVyciA6PSBrLkNoYW5uZWxLZWVwZXIuQ2hhbk9wZW5Jbml0KAogICAgICAgIGN0eCwgbXNnLkNoYW5uZWwuT3JkZXJpbmcsIG1zZy5DaGFubmVsLkNvbm5lY3Rpb25Ib3BzLCBtc2cuUG9ydElkLAogICAgICAgIHBvcnRDYXAsIG1zZy5DaGFubmVsLkNvdW50ZXJwYXJ0eSwgbXNnLkNoYW5uZWwuVmVyc2lvbiwKICAgICkKCiAgICAuLi4KCiAgICAvLyBQZXJmb3JtIGFwcGxpY2F0aW9uIGxvZ2ljIGNhbGxiYWNrCiAgICBpZiBlcnIgPSBjYnMuT25DaGFuT3BlbkluaXQoY3R4LCBtc2cuQ2hhbm5lbC5PcmRlcmluZywgbXNnLkNoYW5uZWwuQ29ubmVjdGlvbkhvcHMsIG1zZy5Qb3J0SWQsIGNoYW5uZWxJRCwgY2FwLCBtc2cuQ2hhbm5lbC5Db3VudGVycGFydHksIG1zZy5DaGFubmVsLlZlcnNpb24pOyBlcnIgIT0gbmlsIHsKICAgICAgICByZXR1cm4gbmlsLCBzZGtlcnJvcnMuV3JhcChlcnIsICZxdW90O2NoYW5uZWwgb3BlbiBpbml0IGNhbGxiYWNrIGZhaWxlZCZxdW90OykKICAgIH0KCiAgICAvLyBXcml0ZSBjaGFubmVsIGludG8gc3RhdGUKICAgIGsuQ2hhbm5lbEtlZXBlci5Xcml0ZU9wZW5Jbml0Q2hhbm5lbChjdHgsIG1zZy5Qb3J0SWQsIGNoYW5uZWxJRCwgbXNnLkNoYW5uZWwuT3JkZXJpbmcsIG1zZy5DaGFubmVsLkNvbm5lY3Rpb25Ib3BzLCBtc2cuQ2hhbm5lbC5Db3VudGVycGFydHksIG1zZy5DaGFubmVsLlZlcnNpb24pCgogICAgcmV0dXJuICZhbXA7Y2hhbm5lbHR5cGVzLk1zZ0NoYW5uZWxPcGVuSW5pdFJlc3BvbnNlewogICAgICAgIENoYW5uZWxJZDogY2hhbm5lbElELAogICAgfSwgbmlsCn0K",url:"https://github.com/cosmos/ibc-go/blob/v7.0.0/modules/core/keeper/msg_server.go#L166"}}),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("h3",{attrs:{id:"capabilities"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#capabilities"}},[e._v("#")]),e._v(" Capabilities")]),e._v(" "),a("p",[e._v("IBC is intended to work in execution environments where modules do not necessarily trust each other. This security is accomplished using a "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-003-dynamic-capability-store.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("dynamic capability store"),a("OutboundLink")],1),e._v(". This binding strategy prevents other modules from using the particular port or channel since those modules do not own the appropriate capability.\n"),a("br"),a("br"),e._v("\nWhile this background information is useful, IBC application developers should not need to modify this lower level abstraction, other than setting the capabilities appropriately in "),a("code",[e._v("app.go")]),e._v(".")])]),e._v(" "),a("h2",{attrs:{id:"application-packet-flow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#application-packet-flow"}},[e._v("#")]),e._v(" Application packet flow")]),e._v(" "),a("p",[e._v("As stated previously, application modules communicate with each other by sending packets over IBC channels. However, IBC modules do not directly pass these messages to each other over the network. Rather, the module will commit some state reflecting the transaction execution to a precisely defined path reserved for a specific message type and a specific counterparty. For example, as part of an ICS-20 token transfer, the bank module would escrow the portion of tokens to be transferred and store the proof of this escrow.")]),e._v(" "),a("p",[e._v("A relayer will monitor channels for events emitted when updates have been submitted to these paths, and (after first submitting a "),a("code",[e._v("MsgUpdateClient")]),e._v(" to update the sending chain light client on the destination chain) relay the message containing the packet data along with a proof that the state transition contained in the message has been commited to the state of the sending chain. The destination chain then verifies this packet and packet commitmentment proof against the state contained in the light client.")]),e._v(" "),a("p",[e._v("Take a look at the "),a("a",{attrs:{href:"https://github.com/cosmos/ibc/tree/main/spec/core/ics-004-channel-and-packet-semantics#definitions",target:"_blank",rel:"noopener noreferrer"}},[e._v("packet definition"),a("OutboundLink")],1),e._v(" to see the packet structure:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"typescript",base64:"aW50ZXJmYWNlIFBhY2tldCB7CiAgc2VxdWVuY2U6IHVpbnQ2NAogIHRpbWVvdXRIZWlnaHQ6IEhlaWdodAogIHRpbWVvdXRUaW1lc3RhbXA6IHVpbnQ2NAogIHNvdXJjZVBvcnQ6IElkZW50aWZpZXIKICBzb3VyY2VDaGFubmVsOiBJZGVudGlmaWVyCiAgZGVzdFBvcnQ6IElkZW50aWZpZXIKICBkZXN0Q2hhbm5lbDogSWRlbnRpZmllcgogIGRhdGE6IGJ5dGVzCn0K"}}),e._v(" "),a("p",[a("code",[e._v("Sequence")]),e._v(" denotes the sequence number of the packet in the channel.")]),e._v(" "),a("p",[a("code",[e._v("TimeoutTimestamp")]),e._v(" and "),a("code",[e._v("TimeoutHeight")]),e._v(" (pick one of these) dictate the time before which the receiving module must process a packet.")]),e._v(" "),a("p",[e._v("The diagram below shows the application packet flow for the success case (top) and unsuccessful or timeout case (bottom). Both cases will be discussed in more detail in the next paragraphs.")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/3-ibc/images/packetflow.png"}})],1),e._v(" "),a("h2",{attrs:{id:"success-case"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#success-case"}},[e._v("#")]),e._v(" Success case")]),e._v(" "),a("p",[e._v("In the first step of a successful packet flow, application A will send a packet (call "),a("code",[e._v("sendPacket")]),e._v(") to application B. "),a("code",[e._v("SendPacket")]),e._v(" can be triggered by a user, but applications can also trigger this as the result of some other application logic.")]),e._v(" "),a("p",[e._v("Core IBC A will commit the packet to its own state and the relayer can query this packet and send a "),a("code",[e._v("RecvPacket")]),e._v(" message to core IBC B. Core IBC handles a number of verifications, including verifying that the packet was indeed sent by chain A, that the packet came in the correct order if it was sent over an ordered channel, that the state commitment proof is valid, etc. If this verification step is successful, core IBC will then route the packet to application B.")]),e._v(" "),a("p",[e._v("Note that core IBC is unopinionated about the actual content of the packet data, as this data is at this point just bytes. It is the responsibility of the applications on either end to marshal and unmarshal the data from and to the expected data structures on either side. This is also why application version negotiation as discussed previously in the channel handshakes is important, as different versions of an application may result in different expected data structures on either end of the channel and application.")]),e._v(" "),a("p",[e._v("After receiving the packet data from core IBC, application B will then marshal the data blob into the expected structure and apply the relevant application logic. In the case of an ICS-20 token transfer, for example, this would entail the minting of the received tokens on chain B to the specified receiver user account. Application B will then send an "),a("code",[e._v("Acknowledgement")]),e._v(" message to core IBC B, which will again commit it to its own state so it can be queried and sent by a relayer to core IBC A.")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("h3",{attrs:{id:"synchronous-and-asynchronous-acknowledgements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronous-and-asynchronous-acknowledgements"}},[e._v("#")]),e._v(" Synchronous and asynchronous acknowledgements")]),e._v(" "),a("p",[e._v("Acknowledgements can either take place synchronously or asynchronously. What this means is that the "),a("code",[e._v("OnRecvPacket")]),e._v(" callback has a return value "),a("code",[e._v("Acknowledgement")]),e._v(" which is optional.\n"),a("br"),a("br"),e._v("\nIn the case of a synchronous "),a("code",[e._v("Acknowledgement")]),e._v(", the callback will return an "),a("code",[e._v("Acknowledgement")]),e._v(" at the end of the process and a relayer can query this "),a("code",[e._v("Acknowledgement")]),e._v(" packet and relay immediately after the process has finished. This is useful in cases in which application A is expecting an "),a("code",[e._v("AckPacket")]),e._v(" in order to initiate some application logic "),a("code",[e._v("OnAcknowledgePacket")]),e._v(". For example, the sending chain of an ICS-20 token transfer will do nothing in the case of a successful "),a("code",[e._v("AckPacket")]),e._v(", but in the case where an error is returned, the sending chain will unescrow the previously locked tokens.\n"),a("br"),a("br"),e._v("\nIn the case of applications like Interchain Security, there is an asynchronous "),a("code",[e._v("Acknowledgement")]),e._v(" flow. This means that the "),a("code",[e._v("Acknowledgement")]),e._v(" is not sent as part of the return value of "),a("code",[e._v("OnRecvPacket")]),e._v(", but it is sent at some later point. IBC is designed to handle this case by allowing for "),a("code",[e._v("Acknowledgements")]),e._v(" to be committed or queried asynchronously.\n"),a("br"),a("br"),e._v("\nIn either case, even if there is no application specific logic to be initiated as a direct result of a received "),a("code",[e._v("Acknowledgement")]),e._v(", "),a("code",[e._v("OnAcknowledgePacket")]),e._v(" will at the very least remove the commitment proof from the store to avoid cluttering the store with old data.")])]),e._v(" "),a("h2",{attrs:{id:"timeout-case"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#timeout-case"}},[e._v("#")]),e._v(" Timeout case")]),e._v(" "),a("p",[e._v("In the case that a packet is time-sensitive and the timeout block height or timeout timestamp specified in the packet parameters "),a("strong",[e._v("based on chain B's time")]),e._v(" has elapsed, whatever state transitions have occured as a result of the sent packet should be reversed.")]),e._v(" "),a("p",[e._v("In these cases, the initial flow is the same, with core IBC A first committing the packet to its own state. However, instead of querying for the packet, a relayer will submit a "),a("code",[e._v("QueryNonReceipt")]),e._v(" to receive a proof that the packet was not received by core IBC B. It can then send the "),a("code",[e._v("MsgTimeout")]),e._v(" to core IBC A, which will then trigger the relevant "),a("code",[e._v("OnTimeoutPacket")]),e._v(" application logic. For example, the ICS-20 token transfer application will unescrow the locked up tokens and send these back to the original sender "),a("code",[e._v("OnTimeoutPacket")]),e._v(".")]),e._v(" "),a("HighlightBox",{attrs:{type:"synopsis"}},[a("p",[e._v("To summarize, this section has explored:")]),e._v(" "),a("ul",[a("li",[e._v("How application to application communication in IBC is conducted over channels, which route data between corresponding modules on different chains, and how a single connection between applications can have any number of associated channels.")]),e._v(" "),a("li",[e._v("How channels are payload agnostic and simply deliver data packets over the transport layer which application modules use their own logic and handlers to interpret and act upon.")]),e._v(" "),a("li",[e._v("How channels can be "),a("strong",[e._v("ordered")]),e._v(" (where data packets are delivered exactly in the order they were sent) or "),a("strong",[e._v("unordered")]),e._v(" (where packets can be delivered in any order, which may differ from that in which they were sent).")]),e._v(" "),a("li",[e._v("How channels are established through a four-way handshake, which allows only the two end modules to make use of the channel, securing them against malicious entities.")]),e._v(" "),a("li",[e._v("How packet flow between modules is not direct - instead, the sending module commits some particular state, thus emitting an event which is detected by a relayer, which delivers to the destination module both the packet data and a proof of the sending module's state commit, which is then verified on the destination chain.")]),e._v(" "),a("li",[e._v("How it is possible for time-sensitive packets to trigger a reversal of the sending module's state change in the event that a timeout block height or timestamp has elapsed.")])])])],1)}),[],!1,null,null,null);t.default=o.exports}}]);