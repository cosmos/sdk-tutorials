(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{718:function(e,t,a){"use strict";a.r(t);var s=a(1),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"baseapp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#baseapp"}},[e._v("#")]),e._v(" BaseApp")]),e._v(" "),a("HighlightBox",{attrs:{type:"prerequisite"}},[a("p",[e._v("Before looking at "),a("code",[e._v("BaseApp")]),e._v(", make sure to read the previous sections:")]),e._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/1-architecture.html"}},[e._v("A Blockchain App Architecture")])],1),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/3-transactions.html"}},[e._v("Transactions")])],1),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/4-messages.html"}},[e._v("Messages")])],1),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/5-modules.html"}},[e._v("Modules")])],1),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/7-multistore-keepers.html"}},[e._v("Multistore and Keepers")])],1)])]),e._v(" "),a("HighlightBox",{attrs:{type:"learning"}},[a("p",[e._v("In this section you will discover how to define an application state machine and service router, how to create custom transaction processing, and how to create periodic processes that execute at the beginning or end of each block.")])]),e._v(" "),a("p",[a("code",[e._v("BaseApp")]),e._v(" is a boilerplate implementation of a Cosmos SDK application. This abstraction implements functionalities that every Interchain application needs, starting with an implementation of the CometBFT Application Blockchain Interface (ABCI).")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v("The CometBFT consensus is application agnostic. It establishes the canonical transaction list and sends confirmed transactions to Cosmos SDK applications for interpretation, and in turn receives transactions from Cosmos SDK applications and submits them to the validators for confirmation.")])]),e._v(" "),a("p",[e._v("Applications that rely on the CometBFT consensus must implement concrete functions that support the ABCI interface. "),a("code",[e._v("BaseApp")]),e._v(" includes an implementation of ABCI so developers are not required to construct one.")]),e._v(" "),a("p",[e._v("ABCI itself includes methods such as "),a("code",[e._v("DeliverTx")]),e._v(", which delivers a transaction. The interpretation of the transaction is an application-level responsibility. Since a typical application supports more than one type of transaction, interpretation implies the need for a service router that will send the transaction to different interpreters based on the transaction type. "),a("code",[e._v("BaseApp")]),e._v(" includes a service router implementation.")]),e._v(" "),a("p",[e._v("As well as an ABCI implementation, "),a("code",[e._v("BaseApp")]),e._v(" also provides a state machine implementation. The implementation of a state machine is an application-level concern because the CometBFT consensus is application-agnostic. The Cosmos SDK state machine implementation contains an overall state that is subdivided into various substates. Subdivisions include module states, persistent states, and transient states. These are all implemented in "),a("code",[e._v("BaseApp")]),e._v(".")]),e._v(" "),a("p",[a("code",[e._v("BaseApp")]),e._v(" provides a secure interface between the application, the blockchain, and the state machine while defining as little as possible about the state machine.")]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v("Watch Julien Robert, Developer Relations Engineer for the Cosmos SDK, introduce BaseApp:")]),e._v(" "),a("YoutubePlayer",{attrs:{videoId:"G6QUIUwYaSU"}})],1),e._v(" "),a("h2",{attrs:{id:"defining-an-application"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defining-an-application"}},[e._v("#")]),e._v(" Defining an application")]),e._v(" "),a("p",[e._v("Developers usually create a custom type for their application by referencing "),a("code",[e._v("BaseApp")]),e._v(" and declaring store keys, keepers, and a module manager, like this:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"dHlwZSBBcHAgc3RydWN0IHsKICAvLyByZWZlcmVuY2UgdG8gYSBCYXNlQXBwCiAgKmJhc2VhcHAuQmFzZUFwcAoKICAvLyBsaXN0IG9mIGFwcGxpY2F0aW9uIHN0b3JlIGtleXMKCiAgLy8gbGlzdCBvZiBhcHBsaWNhdGlvbiBrZWVwZXJzCgogIC8vIG1vZHVsZSBtYW5hZ2VyCn0K"}}),e._v(" "),a("p",[e._v("Extending the application with "),a("code",[e._v("BaseApp")]),e._v(" gives the former access to all the methods of "),a("code",[e._v("BaseApp")]),e._v(". Developers compose their custom application with the modules they want, while not having to concern themselves with the hard work of implementing the ABCI, the service routers, and the state management logic.")]),e._v(" "),a("h3",{attrs:{id:"type-definition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-definition"}},[e._v("#")]),e._v(" Type definition")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("BaseApp")]),e._v(" type holds many "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/v0.40.0-rc3/baseapp/baseapp.go#L46-L131",target:"_blank",rel:"noopener noreferrer"}},[e._v("important parameters"),a("OutboundLink")],1),e._v(" for any Cosmos SDK-based application.")]),e._v(" "),a("h4",{attrs:{id:"bootstrapping"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bootstrapping"}},[e._v("#")]),e._v(" Bootstrapping")]),e._v(" "),a("p",[e._v("Important parameters that are initialized during the bootstrapping of the application are:")]),e._v(" "),a("ul",[a("li",[a("p",[a("strong",[a("code",[e._v("CommitMultiStore")]),e._v(":")]),e._v(" this is the main store of the application, which holds the canonical state that is committed at the end of each block. This store is not cached, meaning it is not used to update the application's volatile (un-committed) states.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("CommitMultiStore")]),e._v(" is a store of stores. Each module of the application uses one or multiple "),a("code",[e._v("KVStores")]),e._v(" in the multistore to persist their subset of the state.")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("Database:")]),e._v(" the database is used by the "),a("code",[e._v("CommitMultiStore")]),e._v(" to handle data persistence.")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("Msg")]),e._v(" service router:")]),e._v(" the "),a("code",[e._v("msgServiceRouter")]),e._v(" facilitates the routing of "),a("code",[e._v("sdk.Msg")]),e._v(" requests to the appropriate module "),a("code",[e._v("Msg")]),e._v(" service for processing.")]),e._v(" "),a("p",[e._v("An "),a("code",[e._v("sdk.Msg")]),e._v(" here refers to the transaction component that needs to be processed by a service to update the application state, and not to the ABCI message, which implements the interface between the application and the underlying consensus engine.")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("gRPC Query Router:")]),e._v(" the "),a("code",[e._v("grpcQueryRouter")]),e._v(" facilitates the routing of gRPC queries to the appropriate module that will process them. These queries are not ABCI messages themselves. They are relayed to the relevant module's gRPC query service.")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("TxDecoder")]),e._v(":")]),e._v(" this is used to decode raw transaction bytes relayed by the CometBFT.")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("ParamStore")]),e._v(":")]),e._v(" this is the parameter store used to get and set application consensus parameters.")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("AnteHandler")]),e._v(":")]),e._v(" this is used to handle signature verification, fee payment, and other pre-message execution checks when a transaction is received. It is executed during "),a("code",[e._v("CheckTx/RecheckTx")]),e._v(" and "),a("code",[e._v("DeliverTx")]),e._v(".")])]),e._v(" "),a("li",[a("p",[a("strong",[a("code",[e._v("InitChainer")]),e._v(", "),a("code",[e._v("BeginBlocker")]),e._v(", and "),a("code",[e._v("EndBlocker")]),e._v(":")]),e._v(" these are the functions executed when the application receives the "),a("code",[e._v("InitChain")]),e._v(", "),a("code",[e._v("BeginBlock")]),e._v(", and "),a("code",[e._v("EndBlock")]),e._v(" ABCI messages from CometBFT.")])])]),e._v(" "),a("h4",{attrs:{id:"volatile-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-state"}},[e._v("#")]),e._v(" Volatile state")]),e._v(" "),a("p",[e._v("Parameters that define volatile states, cached states, include:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("checkState:")]),e._v(" this state is updated during "),a("code",[e._v("CheckTx")]),e._v(" and resets on "),a("code",[e._v("Commit")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("deliverState:")]),e._v(" this state is updated during "),a("code",[e._v("DeliverTx")]),e._v(" and set to nil on "),a("code",[e._v("Commit")]),e._v(". It gets re-initialized on "),a("code",[e._v("BeginBlock")]),e._v(".")])]),e._v(" "),a("h4",{attrs:{id:"consensus-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consensus-parameters"}},[e._v("#")]),e._v(" Consensus parameters")]),e._v(" "),a("p",[e._v("Consensus parameters define the overall consensus state:")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("voteInfos")]),e._v(":")]),e._v(" this parameter carries the list of validators whose pre-commit is missing, either because they did not vote or because the proposer did not include their vote. This information is carried by the context and can be used by the application for various things, like punishing absent validators.")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("minGasPrices")]),e._v(":")]),e._v(" this parameter defines the minimum gas prices accepted by the node. This is a local parameter, meaning each full-node can set a different "),a("code",[e._v("minGasPrices")]),e._v(". It is used in the "),a("code",[e._v("AnteHandler")]),e._v(" during "),a("code",[e._v("CheckTx")]),e._v(" mainly as a spam protection mechanism. The transaction enters the mempool only if the gas prices of the transaction are greater than one of the minimum gas prices in "),a("code",[e._v("minGasPrices")]),e._v(". If "),a("code",[e._v("minGasPrices == 1uatom,1photon")]),e._v(", the gas price of the transaction must be greater than "),a("code",[e._v("1uatom OR 1photon")]),e._v(".")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("appVersion")]),e._v(":")]),e._v(" version of the application set in the application's constructor function.")])]),e._v(" "),a("h3",{attrs:{id:"constructor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[e._v("#")]),e._v(" Constructor")]),e._v(" "),a("p",[e._v("Consider the following simple constructor:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBOZXdCYXNlQXBwKAogIG5hbWUgc3RyaW5nLCBsb2dnZXIgbG9nLkxvZ2dlciwgZGIgZGJtLkRCLCB0eERlY29kZXIgc2RrLlR4RGVjb2Rlciwgb3B0aW9ucyAuLi5mdW5jKCpCYXNlQXBwKSwKKSAqQmFzZUFwcCB7CgogIC8vIC4uLgp9Cg=="}}),e._v(" "),a("p",[e._v("The "),a("code",[e._v("BaseApp")]),e._v(" constructor function is pretty straightforward. Notice the possibility of providing additional "),a("code",[e._v("options")]),e._v(" to the "),a("code",[e._v("BaseApp")]),e._v(", which executes them in order. These options are generally setter functions for important parameters, like "),a("code",[e._v("SetPruning()")]),e._v(" to set pruning options, or "),a("code",[e._v("SetMinGasPrices()")]),e._v(" to set the node's min-gas-prices.")]),e._v(" "),a("p",[e._v("Developers can add additional options based on their application's needs.")]),e._v(" "),a("h2",{attrs:{id:"states"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#states"}},[e._v("#")]),e._v(" States")]),e._v(" "),a("p",[a("code",[e._v("BaseApp")]),e._v(" provides "),a("strong",[e._v("three primary states")]),e._v(". Two are volatile and one is persistent:")]),e._v(" "),a("ul",[a("li",[e._v("The persistent "),a("strong",[e._v("main")]),e._v(" state is the canonical state of the application.")]),e._v(" "),a("li",[e._v("The volatile states "),a("code",[e._v("checkState")]),e._v(" and "),a("code",[e._v("deliverState")]),e._v(" are used to handle transitions between main states during commits.")])]),e._v(" "),a("p",[e._v("There is one single "),a("code",[e._v("CommitMultiStore")]),e._v(", referred to as the main state or root state. "),a("code",[e._v("BaseApp")]),e._v(" derives the two volatile states using a mechanism called branching from this main state which is performed by the "),a("code",[e._v("CacheWrap")]),e._v(" function.")]),e._v(" "),a("h3",{attrs:{id:"initchain-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initchain-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("InitChain")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("The two volatile states "),a("code",[e._v("checkState")]),e._v(" and "),a("code",[e._v("deliverState")]),e._v(" are set by branching the root "),a("code",[e._v("CommitMultiStore")]),e._v(" during "),a("code",[e._v("InitChain")]),e._v(". Any subsequent reads and writes happen on branched versions of the "),a("code",[e._v("CommitMultiStore")]),e._v(". All reads to the branched store are cached to avoid unnecessary roundtrips to the main state.")]),e._v(" "),a("h3",{attrs:{id:"checktx-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checktx-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("CheckTx")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("checkState")]),e._v(", which is based on the last committed state from the root store, is used for any reads and writes during "),a("code",[e._v("CheckTx")]),e._v(". Here, you only execute the "),a("code",[e._v("AnteHandler")]),e._v(" and verify a service router exists for every message in the transaction.")]),e._v(" "),a("p",[e._v("Note that you branch the already branched "),a("code",[e._v("checkState")]),e._v(" when you execute the "),a("code",[e._v("AnteHandler")]),e._v(". This has the side effect that if the "),a("code",[e._v("AnteHandler")]),e._v(" fails, the state transitions will not be reflected in the "),a("code",[e._v("checkState")]),e._v(". "),a("code",[e._v("checkState")]),e._v(" is only updated on success.")]),e._v(" "),a("h3",{attrs:{id:"beginblock-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beginblock-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("BeginBlock")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("deliverState")]),e._v(" is set for use in subsequent "),a("code",[e._v("DeliverTx")]),e._v(" ABCI messages during "),a("code",[e._v("BeginBlock")]),e._v(". "),a("code",[e._v("deliverState")]),e._v(" is based on the last committed state from the root store, and is branched.")]),e._v(" "),a("p",[e._v("Note the "),a("code",[e._v("deliverState")]),e._v(" is set to nil on "),a("code",[e._v("Commit")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"delivertx-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delivertx-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("DeliverTx")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("The state flow for "),a("code",[e._v("DeliverTx")]),e._v(" is nearly identical to "),a("code",[e._v("CheckTx")]),e._v(", except state transitions occur on the "),a("code",[e._v("deliverState")]),e._v(" and messages in a transaction are executed. Similarly to "),a("code",[e._v("CheckTx")]),e._v(", state transitions occur on a doubly branched state, "),a("code",[e._v("deliverState")]),e._v(". Successful message execution results in writes being committed to "),a("code",[e._v("deliverState")]),e._v(".")]),e._v(" "),a("p",[e._v("If message execution fails, state transitions from the "),a("code",[e._v("AnteHandler")]),e._v(" are persisted.")]),e._v(" "),a("h3",{attrs:{id:"commit-state-updates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commit-state-updates"}},[e._v("#")]),e._v(" "),a("code",[e._v("Commit")]),e._v(" state updates")]),e._v(" "),a("p",[e._v("All the state transitions that occurred in "),a("code",[e._v("deliverState")]),e._v(" are finally written during "),a("code",[e._v("Commit")]),e._v(" to the root "),a("code",[e._v("CommitMultiStore")]),e._v(", which in turn is committed to disk and results in a new application root hash. These state transitions are now considered final. The "),a("code",[e._v("checkState")]),e._v(" is finally set to the newly committed state and "),a("code",[e._v("deliverState")]),e._v(" is set to nil to be reset on "),a("code",[e._v("BeginBlock")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"paramstore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paramstore"}},[e._v("#")]),e._v(" "),a("code",[e._v("ParamStore")])]),e._v(" "),a("p",[e._v("During "),a("code",[e._v("InitChain")]),e._v(", the "),a("code",[e._v("RequestInitChain")]),e._v(" provides "),a("code",[e._v("ConsensusParams")]),e._v(", which contains parameters related to block execution such as maximum gas and size in addition to evidence parameters. If these parameters are non-nil, they are set in the "),a("code",[e._v("BaseApp")]),e._v("'s "),a("code",[e._v("ParamStore")]),e._v(". The "),a("code",[e._v("ParamStore")]),e._v(" is managed behind the scenes by an "),a("code",[e._v("x/params")]),e._v(" module subspace. This allows the parameters to be tweaked via on-chain governance.")]),e._v(" "),a("h2",{attrs:{id:"service-routers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-routers"}},[e._v("#")]),e._v(" Service routers")]),e._v(" "),a("p",[e._v("When messages and queries are received by the application, they must be routed as is appropriate to be processed. Routing is done via "),a("code",[e._v("BaseApp")]),e._v(", which holds a "),a("code",[e._v("msgServiceRouter")]),e._v(" for messages and a "),a("code",[e._v("grpcQueryRouter")]),e._v(" for queries.")]),e._v(" "),a("h3",{attrs:{id:"msg-service-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#msg-service-router"}},[e._v("#")]),e._v(" "),a("code",[e._v("Msg")]),e._v(" service router")]),e._v(" "),a("HighlightBox",{attrs:{type:"docs"}},[a("p",[e._v("Are you looking for more information on "),a("code",[e._v("BaseApp")]),e._v("? See the "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/master/docs/docs/core/00-baseapp.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cosmos SDK documentation"),a("OutboundLink")],1),e._v(".")])]),e._v(" "),a("p",[e._v("The main ABCI messages that "),a("code",[e._v("BaseApp")]),e._v(" implements are "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/master/docs/docs/core/00-baseapp.md#checktx",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("CheckTx")]),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/master/docs/docs/core/00-baseapp.md#delivertx",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("DeliverTx")]),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("Other ABCI message handlers being implemented are:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("InitChain")])]),e._v(" "),a("li",[a("code",[e._v("BeginBlock")])]),e._v(" "),a("li",[a("code",[e._v("EndBlock")])]),e._v(" "),a("li",[a("code",[e._v("Commit")])]),e._v(" "),a("li",[a("code",[e._v("Info")])]),e._v(" "),a("li",[a("code",[e._v("Query")])])]),e._v(" "),a("ExpansionPanel",{attrs:{title:"Show me some code for my checkers blockchain"}},[a("p",[a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/7-multistore-keepers.html"}},[e._v("Earlier")]),e._v(" in the design of your blockchain, you defined a game deadline. When do you verify that a game has expired?")],1),e._v(" "),a("p",[e._v("An interesting feature of an ABCI application is that you can have it perform some actions at the end of each block. To expire games that have timed out at the end of a block, you need to hook your keeper to the right call.")]),e._v(" "),a("p",[e._v("The Cosmos SDK will call into each module at various points when building the whole application. The function it calls at each block's end looks like this:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAoYW0gQXBwTW9kdWxlKSBFbmRCbG9jayhjdHggc2RrLkNvbnRleHQsIF8gYWJjaS5SZXF1ZXN0RW5kQmxvY2spIFtdYWJjaS5WYWxpZGF0b3JVcGRhdGUgewogICAgLy8gVE9ETwogICAgcmV0dXJuIFtdYWJjaS5WYWxpZGF0b3JVcGRhdGV7fQp9Cg=="}}),e._v(" "),a("p",[e._v("This is where you write the necessary code, preferably in the keeper. For example:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"YW0ua2VlcGVyLkZvcmZlaXRFeHBpcmVkR2FtZXMoc2RrLldyYXBTREtDb250ZXh0KGN0eCkpCg=="}}),e._v(" "),a("p",[e._v("How can you ensure that the execution of this "),a("code",[e._v("EndBlock")]),e._v(" does not become prohibitively expensive? After all, the potential number of games to expire is unbounded, which can be disastrous in the blockchain world. Is there a situation or attack vector that makes this a possibility? And what can you do to prevent it?\n"),a("br"),a("br"),e._v("\nThe timeout duration is "),a("strong",[e._v("fixed")]),e._v(", and is the same for all games. This means that the "),a("code",[e._v("n")]),e._v(" games that expire in a given block have all been created or updated at roughly the same time, or block height "),a("code",[e._v("h")]),e._v(", with margins of error "),a("code",[e._v("h-1")]),e._v(" and "),a("code",[e._v("h+1")]),e._v(".\n"),a("br"),a("br"),e._v("\nThese created and updated games are limited in number, because (as established in the chain consensus parameters) every block has a maximum amount of gas and therefore a limited number of transactions it can include. If by chance all games in blocks "),a("code",[e._v("h-1")]),e._v(", "),a("code",[e._v("h")]),e._v(", and "),a("code",[e._v("h+1")]),e._v(" expire now, then the "),a("code",[e._v("EndBlock")]),e._v(" function would have to expire three times as many games as a block can handle with its transactions. This is a worst-case scenario, but most likely it is still manageable.")]),e._v(" "),a("br"),e._v(" "),a("HighlightBox",{attrs:{type:"warn"}},[a("p",[e._v("Be careful about letting the game creator pick a timeout duration. This could allow a malicious actor to stagger game creations over a large number of blocks "),a("em",[e._v("with decreasing timeouts")]),e._v(", so that they all expire at the same time.")])])],1),e._v(" "),a("HighlightBox",{attrs:{type:"tip"}},[a("p",[e._v("If you want to go beyond out-of-context code samples like the above and see in more detail how to define these features, go to "),a("RouterLink",{attrs:{to:"/hands-on-exercise/1-ignite-cli/"}},[e._v("Run Your Own Cosmos Chain")]),e._v(".\n"),a("br"),a("br"),e._v("\nMore precisely, you can jump to:")],1),e._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/hands-on-exercise/2-ignite-cli-adv/4-game-forfeit.html"}},[e._v("Auto-Expiring Games")]),e._v(" to see how to implement the expiration of games in "),a("code",[e._v("EndBlock")]),e._v(".")],1)])]),e._v(" "),a("HighlightBox",{attrs:{type:"synopsis"}},[a("p",[e._v("To summarize, this section has explored:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("BaseApp")]),e._v(", a boilerplate implementation of a Cosmos SDK application which provides core functionalities (such as ABCI) and a state machine implementation.")]),e._v(" "),a("li",[e._v("How "),a("code",[e._v("BaseApp")]),e._v(" delivers a secure interface between application, blockchain, and state machine while defining the state machine as little as possible.")]),e._v(" "),a("li",[e._v("How to begin defining an application by declaring store keys, keepers, and a module manager.")]),e._v(" "),a("li",[e._v("The three primary states of "),a("code",[e._v("BaseApp")]),e._v(" (the persistent canonical main state of the application, and the two volatile states used to handle transitions during commits, "),a("code",[e._v("checkState")]),e._v(" and "),a("code",[e._v("deliverState")]),e._v("), as well as a variety of state updates used by applications.")]),e._v(" "),a("li",[e._v("The use of service routers for handling messages and queries.")])])])],1)}),[],!1,null,null,null);t.default=o.exports}}]);