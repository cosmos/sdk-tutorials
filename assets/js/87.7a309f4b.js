(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{705:function(e,t,a){"use strict";a.r(t);var o=a(1),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"a-blockchain-app-architecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-blockchain-app-architecture"}},[e._v("#")]),e._v(" A Blockchain App Architecture")]),e._v(" "),a("HighlightBox",{attrs:{type:"learning"}},[a("p",[e._v("In this section, you will look closer at the application architecture underlying blockchains built with the Cosmos SDK.")]),e._v(" "),a("p",[e._v("In this section, you will deepen your understanding of the application architecture underlying blockchains built with the Cosmos SDK. You will explore:")]),e._v(" "),a("ul",[a("li",[e._v("What Tendermint and CometBFT is")]),e._v(" "),a("li",[e._v("Consensus in the Interchain")]),e._v(" "),a("li",[e._v("The Application Blockchain Interface")]),e._v(" "),a("li",[e._v("The Cosmos SDK")]),e._v(" "),a("li",[e._v("State machines")])])]),e._v(" "),a("h2",{attrs:{id:"what-are-tendermint-and-cometbft"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-are-tendermint-and-cometbft"}},[e._v("#")]),e._v(" What are Tendermint and CometBFT?")]),e._v(" "),a("p",[e._v("Created in 2014, "),a("a",{attrs:{href:"https://tendermint.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint"),a("OutboundLink")],1),e._v(" accelerates the development of distinct blockchains with a ready-made networking and consensus solution, so developers do not have to recreate these features for each new case. You may already use Tendermint without being aware of it.")]),e._v(" "),a("p",[e._v("Tendermint modules "),a("strong",[e._v("attend to consensus and networking")]),e._v(", which are important components of any blockchain. This frees developers to focus on the application level without descending into lower-level blockchain concerns such as peer discovery, block propagation, consensus, and transaction finalization. Without Tendermint, developers would be forced to build software to address these concerns, which would add additional time, complexity, and cost to the development of their applications.")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/2-cosmos-concepts/images/architecture_overview.png"}})],1),e._v(" "),a("p",[e._v("A blockchain node for an application-focused Cosmos blockchain consists of a state-machine, built with the Cosmos SDK, and the consensus and networking layer, which are handled by "),a("a",{attrs:{href:"https://docs.cometbft.com/v0.37/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CometBFT"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("ExpansionPanel",{attrs:{title:"What is CometBFT?"}},[a("p",[e._v("CometBFT is a blockchain application platform which supports state machines in any language. The language-agnostic CometBFT helps developers securely and consistently replicate deterministic, finite state machines.\n"),a("br"),a("br"),e._v("\nCometBFT is maintained even when 1/3rd of all machines fail, by providing two components:")]),e._v(" "),a("ul",[a("li",[e._v("A blockchain consensus engine.")]),e._v(" "),a("li",[e._v("A generic application interface.")])]),e._v(" "),a("HighlightBox",{attrs:{type:"tip"}},[a("p",[e._v("Want to continue exploring this useful component of the Cosmos SDK? Find further information through the "),a("a",{attrs:{href:"https://docs.cometbft.com/v0.37/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CometBFT documentation"),a("OutboundLink")],1),e._v(".")])])],1),e._v(" "),a("h2",{attrs:{id:"consensus-with-cometbft-and-the-interchain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consensus-with-cometbft-and-the-interchain"}},[e._v("#")]),e._v(" Consensus with CometBFT and the Interchain")]),e._v(" "),a("p",[e._v("CometBFT is a high-performance, consistent, flexible, and secure "),a("strong",[e._v("consensus")]),e._v(" module with strict fork accountability. It relies on Proof-of-Stake (PoS) with delegation and "),a("a",{attrs:{href:"https://arxiv.org/abs/1807.04938",target:"_blank",rel:"noopener noreferrer"}},[e._v("Practical Byzantine Fault Tolerance"),a("OutboundLink")],1),e._v(". Participants signal support for well-behaved, reliable nodes that create and confirm blocks. Users signal support by staking ATOM, or the native token of the respective chain. Staking bears the possibility of acquiring a share of the network transaction fees, but also the risk of reduced returns or even losses should the supported node become unreliable.")]),e._v(" "),a("p",[e._v("Network participants are incentivized to stake their ATOM with nodes which are the most likely to provide dependable service, and to withdraw their support should those conditions change. A Cosmos blockchain is expected to adjust the validator configuration and continue even in adverse conditions.")]),e._v(" "),a("p",[e._v("Only the top 175 nodes (as ranked by staked ATOM) participate in the transaction finalization process as "),a("strong",[e._v("validators")]),e._v(". The privilege of creating a block is awarded in proportion to the voting power a validator has. "),a("strong",[e._v("Voting power")]),e._v(" is calculated as all ATOM tokens staked by a validator and its delegates. For example, if a given validator's voting power is 15% of the total voting power of all validators, then the validator can expect to receive the block creation privilege 15% of the time.")]),e._v(" "),a("p",[e._v("The created block is broadcast to the other validators, who are expected to respond promptly and correctly:")]),e._v(" "),a("ul",[a("li",[e._v("Validators confirm candidate blocks.")]),e._v(" "),a("li",[e._v("Validators absorb penalties for failing to do so.")]),e._v(" "),a("li",[e._v("Validators can and must reject invalid blocks.")]),e._v(" "),a("li",[e._v("Validators accept the block by returning their signature.")])]),e._v(" "),a("p",[e._v("When sufficient signatures have been collected by the block creator, the block is finalized and broadcast to the wider network. There is no ambiguity in this process: either a block has the necessary signatures or it does not. If it does, insufficient signatories exist to overturn the block and so the block can be understood as "),a("strong",[e._v("finalized")]),e._v(" - there is no process in which the blockchain would be reorganized. This provides a level of certainty when it comes to transaction finality that a probabilistic system like Proof-of-Work (PoW) cannot match.")]),e._v(" "),a("p",[e._v("Aggressive block times are feasible because the process aims for high performance and is based on dedicated validators with good network connectivity. This is quite different from PoW, which favors inclusion and must accommodate slower nodes with greater latency and less reliability. A Cosmos blockchain can handle thousands of transactions per second, with confirmations taking seven seconds.")]),e._v(" "),a("p",[e._v("Even though validation is delegated to a subset of all network nodes, the process avoids concentration of power. The community of users elects validators by staking ATOM and participating in both the rewards and the risks of committing, to provide a reliable, responsible block validation service.")]),e._v(" "),a("h2",{attrs:{id:"upgradeability-of-chains"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#upgradeability-of-chains"}},[e._v("#")]),e._v(" Upgradeability of chains")]),e._v(" "),a("p",[e._v("In any known blockchain, a change in the implementation requires an upgrade to the node software running on each node. In a disorderly process with voluntary participation, this can result in a hard fork: a situation in which one constituency forges ahead with the old rules while another adopts new rules. While this arrangement has positive aspects and proponents, it also has clear disadvantages in settings where "),a("strong",[e._v("certainty")]),e._v(" is a strict requirement. For example, uncertainty about transaction finality (regardless of the degree of uncertainty) may be unacceptable in settings that are concerned with authoritative registries and large assets.")]),e._v(" "),a("p",[e._v("In a CometBFT blockchain, transactions are irreversibly finalized upon block creation, and upgrades are themselves governed by the block creation and validation process. This leaves no room for uncertainty: either the nodes agree to simultaneously upgrade their protocol, or the upgrade proposal fails.")]),e._v(" "),a("p",[e._v("Validators and delegators are the parties who vote on proposals, with weights proportional to their respective stakes. If a delegator does not vote on a proposal, the delegator's vote is taken as that of its delegated validator. This means that delegators should be very demanding when they act, as they also lend their default vote to the validator.")]),e._v(" "),a("h2",{attrs:{id:"application-blockchain-interface-abci"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#application-blockchain-interface-abci"}},[e._v("#")]),e._v(" Application Blockchain Interface (ABCI)")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://docs.cometbft.com/v0.37/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CometBFT"),a("OutboundLink")],1),e._v(" packages the networking and consensus layers of a blockchain and presents an interface to the application layer, the "),a("strong",[e._v("Application Blockchain Interface (ABCI)")]),e._v(". Developers can focus on higher-order concerns and delegate peer-discovery, validator selection, staking, upgrades, and consensus to CometBFT. The consensus engine runs in one process and controls the state machine, while the application runs in another process. The architecture is equally appropriate for "),a("strong",[e._v("private or public blockchains")]),e._v(".")]),e._v(" "),a("p",[e._v("CometBFT is connected to the application by a socket protocol. ABCI provides a socket for applications written in other languages. If the application is written in the same language as the CometBFT implementation, the socket is not used.")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/2-cosmos-concepts/images/ABCI_3.png"}})],1),e._v(" "),a("p",[e._v("CometBFT provides security guarantees, including the following:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Forks")]),e._v(" are never created, provided that at least half the validators are honest.")]),e._v(" "),a("li",[a("strong",[e._v("Strict accountability")]),e._v(" for fork creation allows determination of liability.")]),e._v(" "),a("li",[e._v("Transactions are "),a("strong",[e._v("finalized")]),e._v(" as soon as a block is created.")])]),e._v(" "),a("p",[e._v("CometBFT is not concerned with the interpretation of transactions. That occurs at the application layer. CometBFT presents confirmed, well-formed transactions and blocks of transactions agnostically. CometBFT is un-opinionated about the meaning any transactions have.")]),e._v(" "),a("p",[e._v("The "),a("em",[e._v("block time")]),e._v(" is approximately seven seconds, and blocks may contain thousands of transactions. Transactions are finalized and cannot be overturned as soon as they appear in a block.")]),e._v(" "),a("HighlightBox",{attrs:{type:"reading"}},[a("p",[e._v("For a deeper dive on consensus and CometBFT visit:")]),e._v(" "),a("ul",[a("li",[e._v("This "),a("a",{attrs:{href:"https://softwareengineeringdaily.com/2018/03/26/consensus-systems-with-ethan-buchman/",target:"_blank",rel:"noopener noreferrer"}},[e._v("podcast on consensus systems"),a("OutboundLink")],1),e._v(" with Ethan Buchman")]),e._v(" "),a("li",[e._v("The "),a("a",{attrs:{href:"https://docs.cometbft.com/v0.37/spec/consensus/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CometBFT documentation on consensus"),a("OutboundLink")],1)])])]),e._v(" "),a("p",[e._v("There are at least two broad approaches to "),a("strong",[e._v("application-level concerns")]),e._v(" using blockchains:")]),e._v(" "),a("ol",[a("li",[e._v("Create an application-specific blockchain where everything that can be done is defined in the protocol.")]),e._v(" "),a("li",[e._v("Create a programmable state machine and push application concerns to a higher level, such as bytecode created by compilers interpreting higher-level languages.")])]),e._v(" "),a("p",[e._v("Ethereum-like blockchains are part of the second category: only the state machine is defined in the on-chain protocol, which defines the rules of contract creation, interaction, execution, and little else.")]),e._v(" "),a("p",[e._v("This method is not without its limitations:")]),e._v(" "),a("ul",[a("li",[e._v("Very little is universally defined: standards for basic concerns such as tokens emerge organically through voluntary participation.")]),e._v(" "),a("li",[e._v("Contracts can and do contain repetitive code that may or may not correctly implement the developer's intentions.")]),e._v(" "),a("li",[e._v("This inherent flexibility makes it challenging to reason about what is correct, or even what is friendly.")]),e._v(" "),a("li",[e._v("There are practical limits to the complexity of operations, which are very low compared to what is possible in other settings.")])]),e._v(" "),a("p",[e._v("These limitations make it especially difficult to perform analysis or reorganize data, and developers are forced to adapt to the constraints.")]),e._v(" "),a("p",[e._v("A "),a("strong",[e._v("purpose-built or application-specific blockchain")]),e._v(' is different. There is no need to present a "Turing-complete" language or a general-purpose, programmable state machine because application concerns are addressed by the protocol the developers create.')]),e._v(" "),a("p",[e._v("Developers who have worked with blockchains based on the Ethereum Virtual Machine (EVM) will recognize a shift in the way concerns are addressed. Authorization and access control, the layout of storage and the state, and application governance are not implemented as contracts on a state machine. They instead become properties of a unique blockchain that is built for a singular purpose.")]),e._v(" "),a("h2",{attrs:{id:"the-cosmos-sdk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-cosmos-sdk"}},[e._v("#")]),e._v(" The Cosmos SDK")]),e._v(" "),a("p",[e._v("Developers create the application layer using the "),a("strong",[e._v("Cosmos SDK")]),e._v(". The Cosmos SDK provides:")]),e._v(" "),a("Accordion",{attrs:{items:[{title:"A scaffold to get started",description:"The Cosmos SDK provides a development head start and a pre-established framework for new applications."},{title:"A rich set of modules",description:"The Cosmos SDK provides a rich set of modules that address common concerns such as governance, tokens, other standards, and interactions with other blockchains through the Inter-Blockchain Communication Protocol (IBC)."}]}}),e._v(" "),a("p",[e._v('The creation of an application-specific blockchain with the Cosmos SDK is largely a process of selecting, configuring, and integrating well-solved modules, also known as "composing modules". This greatly reduces the scope of original development required, as development becomes mostly focused on the truly novel aspects of the application.')]),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v("The Inter-Blockchain Communication Protocol (IBC) is a common framework for exchanging information between blockchains. For now, it is enough to know that it exists and it enables seamless interaction between blockchains that want to transfer value (token transfers) and exchange information. It enables communication between applications that run on separate application-specific blockchains.")])]),e._v(" "),a("p",[e._v("The application, consensus, and network layers are contained within the custom blockchain node that forms the foundation of the custom blockchain.")]),e._v(" "),a("p",[e._v("CometBFT passes confirmed transactions to the application layer through the "),a("strong",[e._v("Application Blockchain Interface (ABCI)")]),e._v(". The application layer must implement ABCI, which is a socket protocol. CometBFT is unconcerned with the interpretation of transactions, and the application layer can be unconcerned with propagation, broadcast, confirmation, network formation, and other lower-level concerns that CometBFT attends to (unless it wants to inspect such properties).")]),e._v(" "),a("p",[e._v("Developers are free to create blockchains in any language that supports sockets since the ABCI is a socket protocol, provided their application implements ABCI. ABCI defines the boundary between replication concerns and the application, which is a state machine.")]),e._v(" "),a("p",[e._v("This is itself a considerable step forward that simplifies the creation of unique blockchains.")]),e._v(" "),a("HighlightBox",{attrs:{type:"docs"}},[a("p",[e._v("If you want to continue exploring ABCI, you can find more detailed information here:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/tendermint/abci/blob/master/specification.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABCI GitHub repository: ABCI prose specification"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/tendermint/abci/blob/master/types/types.proto",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint GitHub repository: A Protobuf file on types"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/tendermint/abci/blob/master/types/application.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint GitHub repository: A Go interface"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://docs.cometbft.com/v0.37/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CometBFT documentation"),a("OutboundLink")],1)])])]),e._v(" "),a("h2",{attrs:{id:"state-machines"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-machines"}},[e._v("#")]),e._v(" State machines")]),e._v(" "),a("p",[e._v("A blockchain is a replicated state machine at its core. A "),a("strong",[e._v("state machine")]),e._v(" is a computer science concept, in which a machine can have multiple states but only one state at a time. It follows a state transition process (or a set of defined processes), which is the only way the state changes from the old or "),a("strong",[e._v("initial state ("),a("code",[e._v("S")]),e._v(") to a new state ("),a("code",[e._v("S'")]),e._v(")")]),e._v(".")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/2-cosmos-concepts/images/state_machine_1.png"}})],1),e._v(" "),a("p",[e._v("The "),a("strong",[e._v("state transition function")]),e._v(" in a blockchain is synonymous with a transaction. Given an initial state, a confirmed transaction, and a set of rules for interpreting that transaction, the machine transitions to a new state. The rules of interpretation are defined at the application layer.")]),e._v(" "),a("p",[e._v("Blockchains are deterministic. The only correct interpretation of the transaction is the new state, shown as S-prime ("),a("code",[e._v("S'")]),e._v(") in the previous image.")]),e._v(" "),a("p",[e._v("Blockchains are distributed, and transactions arrive in batches called blocks. The machine state subsists after the correct interpretation of each transaction in a block. Each transaction executes in the context of the state machine that resulted from every preceding transaction. The machine state after all transactions are executed is a useful checkpoint, especially for historic states.")]),e._v(" "),a("p",[e._v('The state of the initialized blockchain, in which "nothing has happened yet", is called '),a("strong",[e._v("Genesis state")]),e._v(" ("),a("code",[e._v("S")]),e._v("). The current state of the blockchain ("),a("code",[e._v("S'")]),e._v(") can always be achieved by applying all the transactions performed to the Genesis state.")]),e._v(" "),a("p",[a("tm-image",{attrs:{src:"/academy/2-cosmos-concepts/images/state_machine_2.png"}})],1),e._v(" "),a("p",[e._v("Developers can create the state machine using the Cosmos SDK. This includes:")]),e._v(" "),a("ul",[a("li",[e._v("Storage organization: also known as "),a("em",[e._v("the state")]),e._v(".")]),e._v(" "),a("li",[e._v("State transition functions: these determine what is permissible and if adjustments to the state result from a transaction.")])]),e._v(" "),a("p",[e._v('In this context, the "consensus" establishes a canonical set of well-ordered blocks containing well-ordered transactions. All nodes agree that the canonical set is the only relevant set of all finalized transactions. There is only one correct interpretation of the canonical transaction set at any given transaction execution or any block height due to the state machine\'s determinism.')]),e._v(" "),a("p",[e._v("This state machine definition is silent on the processes that confirm and propagate transactions. CometBFT is agnostic to the interpretation of the blocks it organizes. The Tendermint consensus establishes the ordered set of transactions. The nodes then reach consensus about the state of the application.")]),e._v(" "),a("h2",{attrs:{id:"additional-details"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#additional-details"}},[e._v("#")]),e._v(" Additional details")]),e._v(" "),a("p",[e._v("Transactions and blocks utilize several key methods and message types:")]),e._v(" "),a("h3",{attrs:{id:"checktx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checktx"}},[e._v("#")]),e._v(" "),a("code",[e._v("CheckTx")])]),e._v(" "),a("p",[e._v("Many transactions that could be broadcast should not be broadcast. Examples include malformed transactions and spam-like artifacts. However, CometBFT cannot determine the transaction interpretation because it is agnostic to it. To address this, the Application Blockchain Interface includes a "),a("code",[e._v("CheckTx")]),e._v(" method. CometBFT uses this method to ask the application layer if a transaction is valid. Applications implement this function.")]),e._v(" "),a("h3",{attrs:{id:"delivertx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delivertx"}},[e._v("#")]),e._v(" "),a("code",[e._v("DeliverTx")])]),e._v(" "),a("p",[e._v("CometBFT calls the "),a("code",[e._v("DeliverTx")]),e._v(" method to pass block information to the application layer for interpretation and possible state machine transition.")]),e._v(" "),a("h3",{attrs:{id:"beginblock-and-endblock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beginblock-and-endblock"}},[e._v("#")]),e._v(" "),a("code",[e._v("BeginBlock")]),e._v(" and "),a("code",[e._v("EndBlock")])]),e._v(" "),a("p",[a("code",[e._v("BeginBlock")]),e._v(" and "),a("code",[e._v("EndBlock")]),e._v(" messages are sent through the ABCI even if blocks contain no transactions. This provides positive confirmation of basic connectivity and helps identify time periods with no operations. These methods facilitate the execution of scheduled processes that should always run because they call methods at the application level, where developers define processes.")]),e._v(" "),a("HighlightBox",{attrs:{type:"tip"}},[a("p",[e._v("It is wise to be cautious about adding too much computational weight at the start or completion of each block, as blocks arrive at approximately seven-second intervals. Too much work could slow down your blockchain.")])]),e._v(" "),a("p",[e._v("Any application that uses CometBFT for consensus must implement ABCI. You do not have to do this manually, because the Cosmos SDK provides a boilerplate known as "),a("strong",[e._v("BaseApp")]),e._v(" to get you started.")]),e._v(" "),a("p",[e._v("In the following suggested exercise, you will create a minimal distributed state machine with the Cosmos SDK and see code samples implementing concepts progressively. Your state machine will rely on CometBFT for consensus.")]),e._v(" "),a("h2",{attrs:{id:"test-yourself-a-pseudo-coding-exercise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-yourself-a-pseudo-coding-exercise"}},[e._v("#")]),e._v(" Test yourself - a pseudo-coding exercise")]),e._v(" "),a("p",[e._v("With all you have learned about Tendermint and CometBFt, can you "),a("strong",[e._v("design")]),e._v(" a minimal distributed state machine, and think about relevant pseudo-code, for a blockchain that allows people to play the game of checkers? Open the following section, "),a("strong",[e._v("Creating a checkers blockchain")]),e._v(", to start this reflection and reinforce your understanding of Tendermint.")]),e._v(" "),a("p",[e._v("You will continue to apply what you learn in later sections to your checkers game, and design a blockchain by using elements of the Cosmos SDK. Alternatively, you can continue directly to learn about "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/2-accounts.html"}},[e._v("accounts in the Cosmos SDK")]),e._v(".")],1),e._v(" "),a("ExpansionPanel",{attrs:{title:"Creating a checkers blockchain"}},[a("p",[a("em",[e._v("Why develop a game of checkers?")]),e._v(" "),a("br"),a("br"),e._v("\nThis "),a("strong",[e._v("design project")]),e._v(" is meant to get you thinking and will evolve in stages as you learn more about Cosmos SDK concepts. You will better understand and experience how the Cosmos SDK improves your productivity by handling the boilerplate as you progress your design through the following sections and explore what the boilerplate does.")]),e._v(" "),a("br"),e._v(" "),a("HighlightBox",{attrs:{type:"tip"}},[a("p",[e._v("This is meant as a design exercise. If you want to go from the design phase to the "),a("strong",[e._v("implementation")]),e._v(" phase, head to "),a("RouterLink",{attrs:{to:"/hands-on-exercise/1-ignite-cli/"}},[e._v("Run Your Own Cosmos Chain")]),e._v(", which is a completely separate exercise.")],1),e._v(" "),a("p",[e._v("You are free to think about design here and in the following concept pages, and then jump to a related section of the exercise.")])]),e._v(" "),a("h3",{attrs:{id:"the-setup"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-setup"}},[e._v("#")]),e._v(" The setup")]),e._v(" "),a("p",[e._v("You are going to design a blockchain that lets people play checkers against each other. There are many versions of checkers, so choose "),a("a",{attrs:{href:"https://www.ducksters.com/games/checkers_rules.php",target:"_blank",rel:"noopener noreferrer"}},[e._v("these simple rules"),a("OutboundLink")],1),e._v(" for this exercise. The object of the exercise is to understand ABCI and learn more about working with the Cosmos SDK, not to get lost in the proper implementation of the board state or the rules of the game.\n"),a("br"),a("br"),e._v("\nUse and adapt "),a("a",{attrs:{href:"https://github.com/batkinson/checkers-go/blob/a09daeb/checkers/checkers.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("this ready-made implementation"),a("OutboundLink")],1),e._v(", including the additional rule that the board is 8x8 and played on black cells. The code will likely require adaptations as you progress. Do not worry about implementing a marketable GUI, that is a separate design project in itself. You must first create the foundation that will ensure a GUI is "),a("em",[e._v("possible")]),e._v(".")]),e._v(" "),a("br"),e._v(" "),a("HighlightBox",{attrs:{type:"info"}},[a("p",[e._v("When you revisit this design exercise in later chapters, the goal will be to improve it with the Cosmos SDK as you learn about its different components. If you are not interested in learning more about ABCI, it is safe to omit "),a("em",[e._v("this")]),e._v(" exercise and move directly to the other learning elements.")])]),e._v(" "),a("p",[e._v("There is a lot you need to do beyond implementing the rules of the game, so simplify as much as possible. Examine these "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ABCI specs"),a("OutboundLink")],1),e._v(" to see what the application needs in order to comply with ABCI. Try to identify which basic resources you would use to make a first, "),a("em",[e._v("imperfect")]),e._v(" checkers game blockchain.")]),e._v(" "),a("h3",{attrs:{id:"make-the-state-machine"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#make-the-state-machine"}},[e._v("#")]),e._v(' "Make" the state machine')]),e._v(" "),a("p",[e._v("You want to have a minimum viable ABCI state machine. CometBFT does not concern itself with whether proposed transactions are valid or how the state changes after each transaction. It delegates this to the state machine, which "),a("em",[e._v("interprets")]),e._v(" transactions as game moves and states.\n"),a("br"),a("br"),e._v("\nThe following are the important junctures at which the application must act:")]),e._v(" "),a("h4",{attrs:{id:"start-the-application"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#start-the-application"}},[e._v("#")]),e._v(" Start the application")]),e._v(" "),a("p",[e._v("This state machine is an application that must start before it can receive any requests from CometBFT. It must load into the memory static elements representing the acceptable general moves.\n"),a("br"),a("br"),e._v("\nThis code exists already and is run automatically when the module is loaded:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBpbml0KCkK",url:"https://github.com/batkinson/checkers-go/blob/a09daeb/checkers/checkers.go#L75"}}),e._v(" "),a("h4",{attrs:{id:"query-the-game-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#query-the-game-state"}},[e._v("#")]),e._v(" "),a("code",[e._v("Query")]),e._v(" - "),a("em",[e._v("the")]),e._v(" game state")]),e._v(" "),a("p",[e._v("To simplify, begin with only a single game and a single board. You can decide immediately how to serialize the board without any effort by using this function:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAoZ2FtZSAqR2FtZSkgU3RyaW5nKCkgc3RyaW5nCg==",url:"https://github.com/batkinson/checkers-go/blob/a09daeb/checkers/checkers.go#L303"}}),e._v(" "),a("p",[e._v("Store the board at "),a("code",[e._v("/store/board")]),e._v(" and return it in the response's "),a("code",[e._v("Value")]),e._v(" when requested via the "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md#query-1",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("Query")]),a("OutboundLink")],1),e._v(" command at "),a("code",[e._v('path = "/store/board"')]),e._v(". If and when you need to re-instantiate the board state out of its serialized form, call:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyBQYXJzZShzIHN0cmluZykgKCpHYW1lLCBlcnJvcikK",url:"https://github.com/batkinson/checkers-go/blob/a09daeb/checkers/checkers.go#L331"}}),e._v(" "),a("p",[e._v("The "),a("code",[e._v("String()")]),e._v(" function does not save the "),a("code",[e._v(".Turn")]),e._v(" field. You must store whose turn it is to play on your own. Choose a "),a("code",[e._v("string")]),e._v(" at "),a("code",[e._v("/store/turn")]),e._v(" for the color of the player.\n"),a("br"),a("br"),e._v("\nYour application needs its own database to store the state. The application must store a state at a certain Merkle root value to be able to recall past states at a later date. This is another implementation "),a("em",[e._v("detail")]),e._v(" that you must address when creating your application.")]),e._v(" "),a("h4",{attrs:{id:"initchain-the-initial-chain-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initchain-the-initial-chain-state"}},[e._v("#")]),e._v(" "),a("code",[e._v("InitChain")]),e._v(" - the initial chain state")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md#initchain",target:"_blank",rel:"noopener noreferrer"}},[e._v("This is where"),a("OutboundLink")],1),e._v(" your only game is initialized. CometBFT sends "),a("code",[e._v("app_state_bytes: bytes")]),e._v(" to your application with the initial (genesis) state of the blockchain. You already know what it would look like to represent a single game.\n"),a("br"),a("br"),e._v("\nYour application:")]),e._v(" "),a("ul",[a("li",[e._v("Takes in the initial state.")]),e._v(" "),a("li",[e._v("Saves it in its database, along with the need for "),a("a",{attrs:{href:"https://github.com/batkinson/checkers-go/blob/a09daeb/checkers/checkers.go#L124",target:"_blank",rel:"noopener noreferrer"}},[e._v("black"),a("OutboundLink")],1),e._v(" to play next.")]),e._v(" "),a("li",[e._v("Returns the Merkle root hash corresponding to the genesis state in "),a("code",[e._v("app_hash: bytes")]),e._v(".")])]),e._v(" "),a("p",[e._v("Your application must also handle the list of validators sent by CometBFT. The Cosmos SDK's "),a("strong",[e._v("BaseApp")]),e._v(" will do this.")]),e._v(" "),a("h4",{attrs:{id:"a-serialized-transaction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-serialized-transaction"}},[e._v("#")]),e._v(" A serialized transaction")]),e._v(" "),a("p",[e._v("Next you must decide how to represent a move. In the ready-made implementation, a position "),a("code",[e._v("Pos")]),e._v(" is represented by "),a("a",{attrs:{href:"https://github.com/batkinson/checkers-go/blob/a09daeb/checkers/checkers.go#L42-L45",target:"_blank",rel:"noopener noreferrer"}},[e._v("two "),a("code",[e._v("int")]),a("OutboundLink")],1),e._v(", and a move by "),a("a",{attrs:{href:"https://github.com/batkinson/checkers-go/blob/a09daeb/checkers/checkers.go#L168",target:"_blank",rel:"noopener noreferrer"}},[e._v("two "),a("code",[e._v("Pos")]),a("OutboundLink")],1),e._v(". You can decide to represent a serialized move as four "),a("code",[e._v("int")]),e._v(": the first two for the original position ("),a("code",[e._v("src")]),e._v("), and the next two for the destination position ("),a("code",[e._v("dst")]),e._v(").")]),e._v(" "),a("h4",{attrs:{id:"beginblock-a-new-block-is-about-to-be-created"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beginblock-a-new-block-is-about-to-be-created"}},[e._v("#")]),e._v(" "),a("code",[e._v("BeginBlock")]),e._v(" - a new block is about to be created")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md#beginblock",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("BeginBlock")]),a("OutboundLink")],1),e._v(" instructs the application to load its state in the right location. Inside "),a("code",[e._v("header: Header")]),e._v(" (as per its "),a("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/spec/core/data_structures.md#header",target:"_blank",rel:"noopener noreferrer"}},[e._v("detailed definition"),a("OutboundLink")],1),e._v(") you find:")]),e._v(" "),a("blockquote",[a("p",[a("code",[e._v("AppHash: []byte")]),e._v(": an arbitrary byte array returned by the application after executing and committing the previous block. This serves as the basis to validate any Merkle proofs that come from the ABCI application, and represents the state of the actual application rather than the state of the blockchain itself. The first block's "),a("code",[e._v("block.Header.AppHash")]),e._v(" is given by "),a("code",[e._v("ResponseInitChain.app_hash")]),e._v(".")])]),e._v(" "),a("p",[e._v("This "),a("em",[e._v("implementation detail")]),e._v(" was skipped before instructing the application to load the right state of the application from its database, which includes the correct "),a("code",[e._v("/store/board")]),e._v(". It is important that the application is able to load a known state at "),a("strong",[e._v("any")]),e._v(" point in time. There could have been a crash or a restore of some sort that de-synchronized CometBFT and the application.\n"),a("br"),a("br"),e._v("\nThe application should work off the last state it has arrived at, in case the header has omitted the "),a("code",[e._v("AppHash")]),e._v(" (which should never happen).\n"),a("br"),a("br"),e._v("\nThe application is now ready to respond to the upcoming "),a("code",[e._v("CheckTx")]),e._v(" and "),a("code",[e._v("DeliverTx")]),e._v(" with the state loaded.")]),e._v(" "),a("h4",{attrs:{id:"checktx-a-new-transaction-appears-in-the-transaction-pool"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#checktx-a-new-transaction-appears-in-the-transaction-pool"}},[e._v("#")]),e._v(" "),a("code",[e._v("CheckTx")]),e._v(" - a new transaction appears in the transaction pool")]),e._v(" "),a("p",[e._v("CometBFT "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md#checktx-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("asks"),a("OutboundLink")],1),e._v(" your application whether the transaction is worth keeping at all. For maximum simplification, you are only concerned with whether there is a valid move in the transaction. You check whether there are four "),a("code",[e._v("int")]),e._v(" in the serialized information for this. You can also check that the "),a("code",[e._v("int")]),e._v(" themselves are within the boundaries of the board, for example between "),a("code",[e._v("0")]),e._v(" and "),a("code",[e._v("7")]),e._v(".\n"),a("br"),a("br"),e._v("\nIt is better "),a("strong",[e._v("not")]),e._v(" to check if the move is valid according to the rules of the application.")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAoZ2FtZSAqR2FtZSkgVmFsaWRNb3ZlKHNyYywgZHN0IFBvcykgYm9vbAo=",url:"https://github.com/batkinson/checkers-go/blob/a09daeb/checkers/checkers.go#L168"}}),e._v(" "),a("p",[e._v("Checking whether a move is valid with regards to the board requires knowledge of the board state "),a("em",[e._v("when the transaction is included in a block")]),e._v(". The board is updated only up to the point where the transactions have been delivered. You may have a situation where two transactions are sent, one after the other, and both are valid. If you tested the move in the second transaction against the board state before the first unconfirmed move, it would appear that the second move is invalid. Testing a move on the board at "),a("code",[e._v("CheckTx")]),e._v(" time should be avoided.\n"),a("br"),a("br"),e._v("\nCheck the "),a("em",[e._v("possibility")]),e._v(" of validity of the transaction in "),a("code",[e._v("CheckTx")]),e._v(": reject the transaction if it is malformed, contains invalid inputs, etc., and therefore cannot "),a("em",[e._v("possibly")]),e._v(" be acceptable; but refrain from confirming that it will be successful according to concerns that depend on context.")]),e._v(" "),a("h4",{attrs:{id:"delivertx-a-transaction-is-added-and-needs-to-be-processed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#delivertx-a-transaction-is-added-and-needs-to-be-processed"}},[e._v("#")]),e._v(" "),a("code",[e._v("DeliverTx")]),e._v(" - a transaction is added and needs to be processed")]),e._v(" "),a("p",[e._v("When a pre-checked transaction "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md#delivertx-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("is delivered"),a("OutboundLink")],1),e._v(", it must be applied to the latest board state. You call:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"ZnVuYyAoZ2FtZSAqR2FtZSkgTW92ZShzcmMsIGRzdCBQb3MpIChjYXB0dXJlZCBQb3MsIGVyciBlcnJvcikK",url:"https://github.com/batkinson/checkers-go/blob/a09daeb/checkers/checkers.go#L274"}}),e._v(" "),a("p",[e._v("Resolve any error if necessary.\n"),a("br"),a("br"),e._v("\nYou need to see whether it makes sense to send the transaction back through ABCI. If the transaction succeeded, you keep the new board state in memory ready for the next delivered transaction. You do not save to the storage at this point.\n"),a("br"),a("br"),e._v("\nYou can also choose to define which information should be indexed via "),a("code",[e._v("events: repeated Event")]),e._v(" in the response. The returned values are intended to return information that could be tedious to collect otherwise. This allows fast searches across blocks for values of relevance if indexed.")]),e._v(" "),a("HighlightBox",{attrs:{type:"docs"}},[a("p",[e._v("See "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md#events",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint's ABCI event spec documentation"),a("OutboundLink")],1),e._v(" for what goes into an "),a("code",[e._v("Event")]),e._v(".")])]),e._v(" "),a("p",[e._v("For the sake of the exercise imagine that you emit some information in two events: one about the move itself, and the other about the resulting board state. In pseudo-code form this looks like:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"json",base64:"WwogICAgeyBrZXk6ICZxdW90O25hbWUmcXVvdDssIHZhbHVlOiAmcXVvdDttb3ZlTWV0YWRhdGEmcXVvdDssIGluZGV4OiB0cnVlIH0sCiAgICB7IGtleTogJnF1b3Q7d2hvLXBsYXllciZxdW90OywgdmFsdWU6IGJvb2wsIGluZGV4OiB0cnVlIH0sCiAgICB7IGtleTogJnF1b3Q7aXMtanVtcCZxdW90OywgdmFsdWU6IGJvb2wsIGluZGV4OiBmYWxzZX0sCiAgICB7IGtleTogJnF1b3Q7bWFkZS1raW5nJnF1b3Q7LCB2YWx1ZTogYm9vbCwgaW5kZXg6IGZhbHNlfSwKICAgIHsga2V5OiAmcXVvdDtoYXMtY2FwdHVyZWQmcXVvdDssIHZhbHVlOiBib29sLCBpbmRleDogZmFsc2V9LAogICAgeyBrZXk6ICZxdW90O2hhcy1jYXB0dXJlZC1raW5nJnF1b3Q7LCB2YWx1ZTogYm9vbCwgaW5kZXg6IGZhbHNlfSwKICAgIHsga2V5OiAmcXVvdDtpcy13aW5uaW5nJnF1b3Q7LCB2YWx1ZTogYm9vbCwgaW5kZXg6IHRydWV9Cl0sClsKICAgIHsga2V5OiAmcXVvdDtuYW1lJnF1b3Q7LCB2YWx1ZTogJnF1b3Q7Ym9hcmRTdGF0ZSZxdW90OywgaW5kZXg6IHRydWUgfSwKICAgIHsga2V5OiAmcXVvdDtibGFjay1jb3VudCZxdW90OywgdmFsdWU6IHVpbnQzMiwgaW5kZXg6IGZhbHNlIH0sCiAgICB7IGtleTogJnF1b3Q7YmxhY2sta2luZy1jb3VudCZxdW90OywgdmFsdWU6IHVpbnQzMiwgaW5kZXg6IGZhbHNlIH0sCiAgICB7IGtleTogJnF1b3Q7cmVkLWNvdW50JnF1b3Q7LCB2YWx1ZTogdWludDMyLCBpbmRleDogZmFsc2UgfSwKICAgIHsga2V5OiAmcXVvdDtyZWQta2luZy1jb3VudCZxdW90OywgdmFsdWU6IHVpbnQzMiwgaW5kZXg6IGZhbHNlIH0KXQo="}}),e._v(" "),a("p",[e._v("If you come from the Ethereum world, you will recognize these as Solidity "),a("em",[e._v("events")]),e._v(" with indexed fields that are "),a("em",[e._v("topics")]),e._v(" in the transaction receipt logs. Unlike Ethereum, though, events are not part of the consensus (the block) but instead are handled purely on the node.\n"),a("br"),a("br"),e._v("\nIt would be judicious to inform CometBFT about the "),a("code",[e._v("GasUsed (int64)")]),e._v(". Each move costs the same, so you can return "),a("code",[e._v("1")]),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"endblock-the-block-is-being-finished"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#endblock-the-block-is-being-finished"}},[e._v("#")]),e._v(" "),a("code",[e._v("EndBlock")]),e._v(" - the block is being finished")]),e._v(" "),a("p",[e._v("Ignoring the issue of validators for now, "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md#endblock",target:"_blank",rel:"noopener noreferrer"}},[e._v("this is used"),a("OutboundLink")],1),e._v(" to let CometBFT know what events should be emitted (similarly to how "),a("code",[e._v("DeliverTx")]),e._v(" was handled). You have only checkers moves, so it is not very clear what could be interesting at a later date.\n"),a("br"),a("br"),e._v("\nAssume that you want to tally what happened in the block. You return this aggregate event:")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"undefined",base64:"WwogICAgeyBrZXk6ICZxdW90O25hbWUmcXVvdDssIHZhbHVlOiAmcXVvdDthZ2dyZWdhdGVBY3Rpb24mcXVvdDssIGluZGV4OiB0cnVlIH0sCiAgICB7IGtleTogJnF1b3Q7YmxhY2stY2FwdHVyZWQtY291bnQmcXVvdDssIHZhbHVlOiB1aW50MzIsIGluZGV4OiBmYWxzZSB9LAogICAgeyBrZXk6ICZxdW90O2JsYWNrLWtpbmctY2FwdHVyZWQtY291bnQmcXVvdDssIHZhbHVlOiB1aW50MzIsIGluZGV4OiBmYWxzZSB9LAogICAgeyBrZXk6ICZxdW90O3JlZC1jYXB0dXJlZC1jb3VudCZxdW90OywgdmFsdWU6IHVpbnQzMiwgaW5kZXg6IGZhbHNlIH0sCiAgICB7IGtleTogJnF1b3Q7cmVkLWtpbmctY2FwdHVyZWQtY291bnQmcXVvdDssIHZhbHVlOiB1aW50MzIsIGluZGV4OiBmYWxzZSB9Cl0K"}}),e._v(" "),a("h4",{attrs:{id:"commit-your-work-here-is-done"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commit-your-work-here-is-done"}},[e._v("#")]),e._v(" "),a("code",[e._v("Commit")]),e._v(" - your work here is done")]),e._v(" "),a("p",[e._v("The block is now "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md#commit",target:"_blank",rel:"noopener noreferrer"}},[e._v("confirmed"),a("OutboundLink")],1),e._v(". The application needs to save its state to storage, i.e. to its database. The state, which includes "),a("code",[e._v("/store/board")]),e._v(", is uniquely identified by its Merkle root hash. As per the ABCI, this hash has to be returned in a "),a("code",[e._v("[]byte")]),e._v(" form. For a consensus to be able to emerge, the hash needs to be deterministic after the sequence of the same "),a("code",[e._v("BeginBlock")]),e._v(", the same "),a("code",[e._v("DeliverTx")]),e._v(" methods in the same order and the same "),a("code",[e._v("EndBlock")]),e._v(" as mentioned in "),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/spec/abci/abci.md#determinism",target:"_blank",rel:"noopener noreferrer"}},[e._v("the documentation"),a("OutboundLink")],1),e._v(".\n"),a("br"),a("br"),e._v("\nThe application may also keep a pointer in its database regarding which state is the latest, so it can purge the board from its memory after having returned and saved. The next "),a("code",[e._v("BeginBlock")]),e._v(" will inform the application about which state to load. The application should keep the state in memory to quickly build on it if the next "),a("code",[e._v("BeginBlock")]),e._v(" fails to mention "),a("code",[e._v("AppHash")]),e._v(" or mentions the same "),a("code",[e._v("AppHash")]),e._v(" previously calculated.")]),e._v(" "),a("h3",{attrs:{id:"what-if-you-like-extreme-serialization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-if-you-like-extreme-serialization"}},[e._v("#")]),e._v(" What if you like extreme serialization?")]),e._v(" "),a("p",[e._v("This "),a("code",[e._v("data")]),e._v(" does not strictly need to be a Merkle root hash. It could well be any bytes, as long as:")]),e._v(" "),a("ul",[a("li",[e._v("The result is deterministic and collision-resistant.")]),e._v(" "),a("li",[e._v("The application can recover the state out of it.")])]),e._v(" "),a("p",[e._v("If you took your single board and serialized it differently, you could return the board state as such.\n"),a("br"),a("br"),e._v("\nYou have 64 cells out of which only 32 are being used. Each cell is occupied by either nothing, a black pawn, a black king, a red pawn, or a red king. There are five possibilities, which can easily fit in a byte, so you need 32 bytes to describe the board. Perhaps you can use the very first bit to indicate whose turn it is to play, as the first bit of a byte is never used when counting to five.\n"),a("br"),a("br"),e._v("\nYou now have:")]),e._v(" "),a("ul",[a("li",[e._v("A deterministic blockchain state.")]),e._v(" "),a("li",[e._v("Collision-resistance, since the same value indicates an identical state.")]),e._v(" "),a("li",[e._v("No external database to handle.")]),e._v(" "),a("li",[e._v("The full state always stored in the block header.")])])],1),e._v(" "),a("HighlightBox",{attrs:{type:"tip"}},[a("p",[e._v("The expandable above is meant as a design exercise. If you want to go from the design phase to the "),a("strong",[e._v("implementation")]),e._v(" phase, head to "),a("RouterLink",{attrs:{to:"/hands-on-exercise/1-ignite-cli/"}},[e._v("Run Your Own Cosmos Chain")]),e._v(", which is a completely separate exercise from scratch.\n"),a("br"),a("br"),e._v("\nRelevant to this section on ABCI is the "),a("RouterLink",{attrs:{to:"/hands-on-exercise/2-ignite-cli-adv/4-game-forfeit.html"}},[e._v("Auto-Expiring Games")]),e._v(" section, where you use the Cosmos SDK to implement expiration in "),a("code",[e._v("EndBlock")]),e._v(". Be warned that this is an advanced section of the hands-on-exercise.\n"),a("br"),a("br"),e._v("\nIn the same vein, and advanced too, is the "),a("RouterLink",{attrs:{to:"/hands-on-exercise/4-run-in-prod/3-add-leaderboard.html"}},[e._v("Add Leaderboard Module")]),e._v(" section, where you add an action in "),a("code",[e._v("EndBlock")]),e._v(" to reduce computation burdens.")],1)]),e._v(" "),a("HighlightBox",{attrs:{type:"synopsis"}},[a("p",[e._v("To summarize, this section has explored:")]),e._v(" "),a("ul",[a("li",[e._v('CometBFT, which provides modules that attend to consensus and networking, removing the need for developers to "reinvent the wheel" of lower-level blockchain concerns and freeing them to focus on the application level of their projects.')]),e._v(" "),a("li",[e._v("CometBFT as a DPoS consensus module with pBFT, through which the top 150 nodes (as ranked by total stake) serve as validators for the blockchain. These duties are divided between validators in proportion to their voting power, and delegating users can assign or withdraw staked ATOM to share in the risks and rewards, and to influence validators in favor of good behavior.")]),e._v(" "),a("li",[e._v("How CometBFT ensures the upgradeability of chains without the possibility of forking, since (like blocks) any proposed upgrades must be validated by a majority of nodes, and there is no process for reversing validation after the fact.")]),e._v(" "),a("li",[e._v("The Application Blockchain Interface (ABCI), through which developers are able to work on the higher-order aspects of their projects. The ABCI connects to CometBFT through a socket protocol, and also provides a socket for applications written in other languages, providing additional flexibility to developers.")]),e._v(" "),a("li",[e._v("The Cosmos SDK, an array of well-solved modular components that developers can rapidly configure and integrate to create the foundations for unique, custom-designed applications.")]),e._v(" "),a("li",[e._v("The Inter-Blockchain Communication Protocol (IBC), a common framework within the Interchain which allows information exchange between blockchains both inside and outside the Interchain Ecosystem.")])])]),e._v(" "),a("h2",{attrs:{id:"overview-of-upcoming-content"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#overview-of-upcoming-content"}},[e._v("#")]),e._v(" Overview of upcoming content")]),e._v(" "),a("p",[e._v("The following sections will extend your comprehension of the Cosmos SDK and the usefulness of its features. If you went through the previous design exercise, you may have already spotted several shortcomings in your potential game blockchain as it is presently designed:")]),e._v(" "),a("ul",[a("li",[e._v("Anyone, including the opponent, can post an anonymous transaction and play instead of the intended player. This makes it impossible to know who did what. You need to identify the right player. The Cosmos SDK comes to the rescue with "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/2-accounts.html"}},[e._v("accounts and signatures")]),e._v(".")],1),e._v(" "),a("li",[e._v("You currently have a single game. Multiple games running in parallel would be better, but this would require a well-defined store. Why not explore the Cosmos SDK's "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/7-multistore-keepers.html"}},[e._v("store and keeper")]),e._v("?")],1),e._v(" "),a("li",[e._v("It would be good to have an elegant way to serialize data objects of interest and your transactions. "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/6-protobuf.html"}},[e._v("Protobuf")]),e._v(" can help with this.")],1),e._v(" "),a("li",[e._v("How can you penalize spam and bad transactions, and also to be able to play for money? Incorporate tokens defined in another "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/5-modules.html"}},[e._v("existing Cosmos SDK module")]),e._v(".")],1),e._v(" "),a("li",[e._v("There is a new transaction type: to "),a("em",[e._v("create a game")]),e._v(". The Cosmos SDK "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/11-context.html"}},[e._v("context object")]),e._v(" allows you to tailor gas costs according to transaction type.")],1),e._v(" "),a("li",[e._v("If you need to handle validator lists during communication, the Interchain does this out of the box with "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/8-base-app.html"}},[e._v("BaseApp")]),e._v(".")],1),e._v(" "),a("li",[e._v("Do you want the player's GUI to easily reload any pending games, or let them know whether a move is valid or not? These are good uses of Cosmos SDK "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/9-queries.html"}},[e._v("queries")]),e._v(".")],1),e._v(" "),a("li",[e._v("If you want to use CometBFT to notify players when it's their turn, Cosmos SDK provides that option with "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/10-events.html"}},[e._v("events")]),e._v(".")],1),e._v(" "),a("li",[e._v("What if you want to add changes to your system in the future after production? You can easily handle this with Cosmos SDK "),a("RouterLink",{attrs:{to:"/academy/2-cosmos-concepts/16-migrations.html"}},[e._v("migrations")]),e._v(".")],1)])],1)}),[],!1,null,null,null);t.default=n.exports}}]);